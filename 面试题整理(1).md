1.重绘和重流的区别：

1.重流: reflow, 重绘: repaint

2.重流必定导致重绘, 重绘不一定重流

3.布局改变会发生重流, 元素颜色等改变只会发生重绘

## 重流

元素的大小尺寸、位置发生变化时，会重新计算渲染树，页面要进行重新排版工作，这个过程即是重流

**触发重流的因素**
1.添加、删除可见的dom

2.元素的位置改变

3.元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)

4.页面渲染初始化

5.浏览器窗口尺寸改变

## 重绘

在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等。

## 2.函数声明式和函数表达式的区别:

```
1.函数声明

sum() 可先调用后定义 (预解析)

function sum(x, y){

  return x+y

}

2.函数表达式

var sum = function (x, y) {

  return x+y

}

sum() 先定义后调用
```

函数申明和函数表达式的区别：

  由于预解析函数声明可提前调用，函数表达式不能提前调用

## 3.call,apply,bind区别:

apply() call()改变作用域this指向，传参不同，apply数组，call一个一个，bind绑定后不能改变this指向

```
	var a = 10;
    function f5(x1,x2) {
        return this.a + ' ' + x1 + ' ' + x2;
    }
    var obj5 = {
        a: 100,
        action: f5
    }
    var obj6 = {
        a: 9999
    }
    obj5.action(1,2); // 100 1 2
    console.log(obj5.action.apply(window,[1,2])); // 10 1 2
    console.log(obj5.action.call(this,1,2));
    // obj5.action对象的成员放到window对象上，这样f5指向就是window
    // var a8 = f5.bind(this,1,2); // 10 1 2
    // var a8 = f5.bind(obj6,1,2); // 9999 1 2
    var a8 = f5.bind(obj5,1,2); // 100 1 2
    a8();
    console.log(a8.call(obj6,1,2)); // 100 1 2
    -------------------------------------------------------------------
    var n = 10;
    function f() {
        return this.n
    }
    // f();
    var obj = {
        n: 8,
        f2: f
    }
    var obj2 = {
        n: 999
    }
    console.log(obj.f2.call(obj2,1)); //999
```

## 4.setTimeout的this指向：

```
	//1.简单函数
    function f() {
        console.log(this); // window
    }
    f();

    //2.内置函数 this === window
    setTimeout(f, 1000);
```

## 5.Dow添加，移除，复制，查找节点：

```
1）创建新节点
　　createDocumentFragment() //创建一个DOM片段
　　createElement() //创建一个具体的元素
　　createTextNode() //创建一个文本节点
2）添加、移除、替换、插入
　　appendChild() //添加
　　removeChild() //移除
　　replaceChild() //替换
　　insertBefore() //插入
3）查找
　　getElementsByTagName() //通过标签名称
　　getElementsByName() //通过元素的Name属性的值
　　getElementById() //通过元素Id，唯一性
```

##### 1.创建元素节点

```
document.createElement() 方法 用于创建元素，接受一个参数，即要创建元素的标签名，返回创建的元素节点

var div = document.createElement("div"); //创建一个div元素
div.id = "myDiv"; //设置div的id
div.className = "box"; //设置div的class
创建元素后还要把元素添加到文档树中
```

##### 2.添加元素节点

```
appendChild() 方法 用于向childNodes列表的末尾添加一个节点，返回要添加的元素节点

var ul = document.getElementByIdx("myList"); //获得ul
var li = document.createElement("li"); //创建li
li.innerHTML = "项目四"; //向li内添加文本
ul.appendChild(li); //把li 添加到ul子节点的末尾
```

##### 3.移除元素节点

```
removeChild() 方法，用于移除节点，接受一个参数，即要移除的节点，返回被移除的节点，注意被移除的节点仍然在文档中，不过文档中已没有其位置了

var ul = document.getElementById("myList"); //获得ul
var fromFirstChild = ul.removeChild(ul.firstChild); //移除ul第一个子节点
 
var ul = document.getElementById("myList"); //获得ul
var lis = ul.getElementsByTagName("li") //获取ul中所有li的集合
ul.removeChild(lis[0]); 　　　　　　//移除第一个li，与上面不同，要考虑浏览器之间的差异
```

##### 4.替换元素节点

```
replaceChild() 方法，用于替换节点，接受两个参数，第一参数是要插入的节点，第二个是要替换的节点，返回被替换的节点

var ul = document.getElementById("myList"); //获得ul
var fromFirstChild = ul.replaceChild(ul.firstChild); //替换ul第一个子节点
 
var ul = document.getElementById("myList"); //获得ul;
var li = document.createElement("li"); //创建li
li.innerHTML= "项目四"; //向li内添加文本
var lis = ul.getElementsByTagName("li") //获取ul中所有li的集合
var returnNode = ul.replaceChild(li,lis[1]); //用创建的li替换原来的第二个li
```

##### 5.复制节点

```
cloneNode() 方法，用于复制节点， 接受一个布尔值参数， true 表示深复制（复制节点及其所有子节点）， false 表示浅复制（复制节点本身，不复制子节点）

var ul = document.getElementById("myList"); //获得ul
var deepList = ul.cloneNode(true); //深复制
var shallowList = ul.cloneNode(false); //浅复制
```

## 6.css为什么要初始化：

```
1.浏览器差异

不同浏览器对有些标签的默认值是不同的，如果没对css初始化会出现浏览器之间的页面显示差异

2.提高编码质量

如果不初始化，整个页面做完会很糟糕，重复的css样式很多
```

## 7.css伪类：

```
锚伪类
	a:link {color: #FF0000}		/* 未访问的链接 */
    a:visited {color: #00FF00}	/* 已访问的链接 */
    a:hover {color: #FF00FF}	/* 鼠标移动到链接上 */
    a:active {color: #0000FF}	/* 选定的链接 */
:first-child 伪类来选择元素的第一个子元素
	p:first-child {font-weight: bold;}
	li:first-child {text-transform:uppercase;}
```

W3C："W3C" 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）

![QQ截图20210216004620](C:\Users\华为\Desktop\QQ截图20210216004620.png)

## 8.link和@impoert的区别：

```
link 属于XHTML  标签，而 @import 是 css 提供的
页面被加载时候，link 会同时被加载， 而 @impoert 引用的 css 等到页面被加载完后在加载
@import 只能在IE5以上才能识别， 而 link 是 XHTML标签，无兼容问题
link 方式的权重高于 @import
使用 DOM 控制样式时候，只能使用link标签， @import 不是 DOM可以操控的。
```

## 9.cookie的弊端：

```
cookie作用：

 1.可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用。

 2.保存用户的登陆状态，用户进行登陆，成功登陆后，服务器生成特定的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该		cookie的信息发送给服务器，服务器经过检验，来判断用户是否登陆。

 3.记录用户的行为。
 
cookie弊端：

 1.增加流量消耗，每次请求都需要带上cookie信息。

 2.安全性隐患，cookie使用明文传输。如果cookie被人拦截了，那人就可以取得所有的session信息。

 3.Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉
```

## 10.双向绑定有哪几种方法：

```
1. v-model 指令
<input v-model="text" />
上例不过是一个语法糖，展开来是：
<input
 :value="text"
 @input="e => text = e.target.value"
/>
2. .sync 修饰符
<my-dialog :visible.sync="dialogVisible" />
上例不过是一个语法糖，展开来是：
<my-dialog
 :visible="dialogVisible"
 @update:visible="newVisible => dialogVisible = newVisible"
/>
```

## 11.vue中 {{}}，v-text 和 v-html的区别：

```
<p>{{message}}</p> <!-- 输出：<span>通过双括号绑定</span> -->
<p v-html="html"></p> <!-- 输出：html标签在渲染的时候被解析 -->
<p v-text="text"></p> <!-- 输出：<span>html标签在渲染的时候被源码输出</span> -->

data: {
    message: "<span>通过双括号绑定</span>",
    html: "<span>html标签在渲染的时候被解析</span>",
    text: "<span>html标签在渲染的时候被源码输出</span>",
}

区别：

{{message}}：将数据解析为纯文本，不能输出真正的html，在页面加载时显示{{}}，所以通常使用v-html和v-text代替，且花括号方式在以后可能被取消

v-html="html"：输出真正的html

v-text="text"：将数据解析为纯文本，不能输出真正的html，与花括号的区别是在页面加载时不显示{{}}
```

## 12.减少页面加载的方法：

```
a. 尽量减少页面中重复的HTTP请求数量

b. 服务器开启gzip压缩

c. css样式的定义放置在文件头部

d. Javascript脚本放在文件末尾

e. 压缩合并Javascript、CSS代码

f. 使用多域名负载网页内的多个文件、图片

1.优化图片 

2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）

3.优化CSS（压缩合并css，如margin-top,margin-left...)

4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） 

5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）

6.减少http请求（合并文件，合并图片）。
```

## 13.数组去重：

```
es6
    var arr = [11,43,11,33];
    var s = new Set(arr); //{11, 43, 33}
    
类型转换
1、 ...[]扩展运算符
var arr1 = [...new Set(arr)]; //[11, 43, 33]
2、 Array.from()
var arr2 = Array.from(new Set(arr)); //[11, 43, 33]

es5
    var arr = [11,43,11,33];
    function f() {
        var array = [];
        for(var i=0; i<arr.length; i++) {
            // if(array.indexOf(arr[i]) == -1) { //没有匹配成功
            //     array.push(arr[i]);
            // }
            if (array.includes(arr[i])) {
                // array.push(arr[i]);
            } else {
                array.push(arr[i]);
            }
        }
        return array;
    }
    f();
    
es5
filter(x,index,self)可以为数组提供过滤功能，其中x代表元素，index是与X一同传入元素的索引，而self代表数组本身
indexOf始终返回第一次找到匹配该元素的索引
    var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7];
    var arr2 = arr.filter(function(x, index,self) {
    return self.indexOf(x)===index;
    }); 
    console.log(arr2); //[1, 2, 3, 4, 5, 6 ,7]
    
第一次循环，传入元素1，index(1)的索引为0，而此时1的索引本来就是1，OK，满足。

第二次循环，传入元素2，index(2)的索引为1，而此时2的索引也是1，OK，也满足。

第三次循环，传入元素2，index(2)的索引为1，而此时2的索引为2，OK，不满足，被PASS，这里就是巧妙的借用了indexOf始终查找到第一次出现的位置
```

## 14.深浅拷贝的区别：

```
如何区分深拷贝与浅拷贝，简单来说:
假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，如果B没变，那就是深拷贝
深拷贝像双胞胎，各自独立
浅拷贝像影子，同步变化
var obj = {
    name:'rr',
    id:1
}
var obj2 = obj // 浅拷贝，一旦改变对应的值就都改变了因为指向的是同一个内存地址，值都在堆里，改的话就是改同一个

1.数组 concat() slice()
var arr = ['a','b'];
var arr2 = arr.concat(); // 适用于一级
arr2.push('c');
console.log(arr2);
console.log(arr);

es6
let a = [1,2];
let a2 = [...a]; //浅拷贝 一级
a2[0] = 100;
console.log(a);
console.log(a2);

2.对象
var a = {id:1, name:'a', obj:{id:999}};
var b = new Object(); // 浅拷贝 适用于一级
b.name = a.name;
b.id = a.id;
b.obj = a.obj;
a.name = 'aaa';
a.obj.id = 5000;
console.log(a);
console.log(b);

1.Object.assign() 浅拷贝
var a = {id:1, name:'a', obj:{id:999}};
function fun(obj) {
    var o = {};
    Object.assign(o, obj);
    return o;
}
var a2 = fun(a); // 复制的新值
a2.name = 'a2';
a2.obj.id = 888;
console.log(a);
console.log(a2);

2.JSON.parse(JSON.stringify()) // 深拷贝 不支持function
var obj = {
    name: 'Ethan',
    age: 25,
    obj: {id: 222},
    action: function() {
       console.log(this.name); 
    }
}
var obj2 = JSON.parse(JSON.stringify(obj));
obj.name = 'Lay';
obj.obj.id = 333;
console.log(obj);
console.log(obj2);
```

## 15.遍历属性:

```
var o5 = {name: 'a', age: 5};
for(var key in o5) {
    console.log(key); // name age
    console.log(o5['key']); // a 5
}
var o6 = ['a','b','c'];
for(var v in o6) {
    console.log(v); // 下标 0 1 2
    console.log(o6['v']); // a b c
}
```

## 16.数组遍历：map() for() forEach() filter():

```
for()
var o7 = ['a','b','c'];
for(var i = 0; i < o7.length; i++) {
    console.log(o7[i]);
}

forEach()
var o7fun = o7.forEach(function(item, index) { // o7[i] == item
    console.log(item);
    return item+1; // 没有返回值
})
console.log(o7fun);

map()
var o8fun = o7.map(function(item, index) { // o7[i] == item
    console.log(item);
    return item+1; // 有返回值
})
console.log(o8fun);

filter()
var o8 = [20,11,3434,223];
var o9fun = o8.filter(function(item) {
    return item > 100;
})
console.log(o9fun);

reduce() // 累加器
var c1 = [20,11,3434,223];
var c1fun = c1.reduce(function(total, cur) { // total 每次累加后的结果 // cur 当前要累加的数据
    return total+cur;
}, 20);
console.log(c1fun);
// 先放一个20块 (初始化) +11+3434+223
```

## 17.属性的设置和获取:

```
. []的区别
1.设置
var obj = {
    name: 'a';
    age: 12
}

2.获取
obj.name    .后面只能是键的名字 .只能对应字符串
obj['name'] []里的可以是个变量 通过变量获取用到[]
```

## 18.检测属性:

检测属性 该方法可以判断对象的自有属性是否存在

in 运算符 检测属性是否存在于某个对象中，自有属性和继承属性都返回true

```
var obj={
	name:'sonia',
	age:22
};
console.log('name' in obj);//自有属性
```

hasOwnProperty() 方法用于检测属性是否是自有属性，是则返回true,否则返回false

```
var obj = {
	name:'lily'
};
console.log(obj.hasOwnProperty("name"));
```

区别

```
function Init() {}
Init.prototype.name = 'xyz';  //原型对象

var init = new Init();
init.age = 18;

console.log("name" in init); // true
console.log("age" in init); // true
console.log(init.hasOwnProperty("name"));  //false
console.log(init.hasOwnProperty("age"));  //true
```

## 19.let和var剖析:

```
申明变量 var let
//1.let不存在变量提升
    console.log(a); // a is not defined
    let a = 1;
    
//2.同一个作用域內不能重复定义同一个名称
	let a = 10;
    if(true) {
        let a = 30;
    }
    let a = 20;
    console.log(a); // 'a' has already been declared
    
    let a = 10;
    if(true) {
        let a = 40
        console.log(a) //40
    }
    console.log(a); //10
    
//3.let 块级作用域  var函数作用域
	function fun() {
        var a = 10;
        if(true) {
            var a = 20;
        }
        console.log(a); // 20
    }
    fun();
    // 有着严格的作用域
    function fun() {
        let a = 10;
        if(true) {
            let a = 20;
        }
        console.log(a); // 10
    }
    fun();
   
//4.块级作用域的重要性
    for(var i = 0; i < 5; i++){} //通过var定义的循环，相当于i变为全局
    console.log(i); //var i = 0; var i = 1;.....var i = 5; i被最后的值覆盖

    for(let i = 0; i < 5; i++){} //每一次循环创建的都是新的变量
    console.log(i); //i is not defined

    var arr = [];
    for(var i = 0; i < 5; i++){
        arr[i] = function() {
            console.log(i); // 5
        }
    }
    arr[4]();

    var arr = [];
    for(let i = 0; i < 5; i++){
        arr[i] = function() {
            console.log(i); // 4
        }
    }
    arr[4]();
    
//暂时性死区
    //坑1
    function f(i) {
        let i = 10;
        console.log(i); //Identifier 'i' has already been declared
    }
    f(100);
    //坑2
    function fun() {
        let a = 10;
        if(true) {
            a = 20;
            console.log(a); //Cannot access 'a' before initialization
            let a; //只要是在块级作用域下let声明的，在当前作用域下不能声明同样的名称
        }
    }
    fun();
    //坑3
    let a = b,b = 100; //b is not defined let没有预解析
    function f() {
        console.log(a,b);
    }
    f();
```

## 20.const剖析：

```
//const声明一个只读的常量，一旦声明，常量的值不能改变
//保存let的不存在变量提升，同一个作用域內不能重复定义同一个名称，有着严格的作用域
const x = 12345;
x = 999;
console.log(x); //Assignment to constant variable

const y; //const一旦声明变量，就必须立即初始化，不能留到以后赋值

var a = 10;
let b = 20;
const a = 100; //error
const b = 100; //error

```

## 21.js栈和堆：

```
基础类型：
    string number null Boolean Undefined

    var a1 = 10;
    var b1 = a1;
    a1 = 9;
    console.log(b1); 10

    数据存储到栈
引用类型：
    array object function

    var obj = {id: 100};
    var obj2 = obj;
    obj2.id = 99;
    console.log(obj2); 99

    数据存储到堆
    引用类型数据的地址指针是存储到栈中，访问引用类型的值时，需要先从栈中获得对象的地址指针
    然后通过地址指针找到找到堆中需要的数据
    定义一个对象的地址在栈里，具体的值放在堆里，所有对象的值都放在同一个堆里
```

## 22.图片懒加载：

```
为什么要使用懒加载？
当我们进入到某个页面的时候，会有许多的图片，有些图片可能在下面，当我们点进页面但没有滑动全部展示时，其实下面的图片是没有作用的，这个时候如果说加载了也相当于白加载，而且还降低了网页的加载速度，那懒加载就是只有滚动到可视区域时才加载当前的图片，也就是说不是一次性加载所有的图片，从而在一程度减少服务端的请求及带宽；

懒加载的优点：
提高前端性能，图片在需要的时候才加载，减轻服务的负担，提高页面的加载速度，能够减少带宽

实现原理?
图片的加载是由src的值引起的，当对src赋值时浏览器会请求图片资源，基于这个，可以利用html5的属性data-xxx来保存图片的路径，当我们需要加载图片的时候才将data-xxx的值赋予src，就能实现图片的按需加载，也就是懒加载了；
```

## 23.for in和for of的区别

```
1、for...in 循环：只能获得对象的键名，不能获得键值
   for...of 循环：允许遍历获得键值
   
   const arr = ['red','green','blue'];
   
	// es6
    for(let v of arr) {
        console.log(v); //'red','green','blue'
    }
    
    // 能不能获取arr的索引
    for(let [i,v] of arr.entries()) {
        console.log(i); //0 1 2
        console.log(v); //'red','green','blue'
    }
    
    // es5
    for(let i in arr) {
        console.log(i); //0 1 2
        console.log(arr[i]); //'red','green','blue'
    }
    
2、forEach 循环无法中途跳出，break 命令或 return 命令都不能奏效
	let arr = [1, 2, 3, 5, 9]
    arr.forEach(item => {
      if(item % 2 === 0) {
        return
      }
      console.log('item', item)
    })
    /*
      item 1
      item 3
      item 5
      item 9
    */
    
    for...of 循环可以与break、continue 和 return 配合使用，跳出循环
    for(let item of arr) {
       if(item % 2 === 0) {
         break
       }
       console.log('item', item)
     }
     // item 1
     
3、对于普通对象object不能直接使用 for of 会报错
    var obj = {'a':1,'b':2,'c':3};
    for(let k of obj) {
        console.log(k); //obj is not iterable
    }
	
	// 解决方法
	可以使用 for...in 循环遍历键名
    for(let k in obj) {
        console.log(k);
        console.log(obj[k]);
    }

    // 解决方法
    也可以使用 Object.keys(obj) 方法将对象的键名生成一个数组，然后遍历这个数组
    for(let k of Object.keys(obj)) {
        console.log(k);
    }

    for(let [k,v] of Object.entries(obj)) {
        console.log(k);
        console.log(v);
    }
   
总之，for...in 循环主要是为了遍历对象而生，不适用于遍历数组
for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象
	
```

## 24.router和route的区别

```
router是全局路由的实例,是VueRouter的实例 ， 包括了路由的跳转方法，钩子函数等。

比如：$router.push

导航钩子：

$router.beforeEach((to,from, next)=>{})


$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。

比如：$route.params 
```

## 25.$route.params与$route.query区别

```
params
params的类型：

配置路由格式：/router/:id 传递的方式：<router-link :to="'/user/'+userId">用户</router-link>
配置路由格式：/router/:id 传递的方式：this.$router.push('/user/'+this.userId)
配置路由格式：/router 传递的方式：this.$router.push({name:'User',params: {userId: 666}})
params传递后形成的路径：/router/123,/router/zhangsan
params接受传递的参数：<p>我是{{$route.params.userId}}用户相关信息</p>

query
query的类型：

配置路由格式：/router 传递的方式：this.$router.push({path:'/profile', query: {name:'123', age: 10}})
query传递后形成的路径：/router?id=666&name=zhangsan
query接受传递的参数：<h2>姓名：{{$route.query.name}}</h2>

params和query的区别
query要使用path来引入，params要使用name来引入，接受参数类似，分别是this.$route.query.name和this.$route.params.name
```

## 26.VUEX

```
vuex状态管理模式， 公共仓库，数据处理，响应式的（对应的值发生变化页面发生变化）
vuex响应式的数据，状态管理库中的数据发生变化页面会同步刷新
vuex页面刷新就没了，不会长期保存

核心概念:

State 数据信息

Mutation 更改Vuex的store中的状态的唯一方法是提交 mutation
当触发一个类型为 `increment` 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法
store.commit('increment')

Action 类似于 mutation，不同在于：
- Action 提交的是 mutation，而不是直接变更状态。
- Action 可以包含任意异步操作。
Action 通过 `store.dispatch` 方法触发：$store.dispatch('increment')

Vue Components 相当于用户
Action 相当于产品经理
Mutation 相当于开发人员
State 相当于要改的数据
用户提需求给到产品经理，开发人员实现效果最后呈现给用户
```

## 27.项目中遇到的问题是如何解决的

```
vuex中Action传递参数，默认只能接收两个参数

可以写多个但是在store.js中进入Action只能接收两个，多了接收不了
this.$store.dispatch('CARTCHANGE',v,'add');

参数比较多可以用对象的方式传进去
this.$store.dispatch('CARTCHANGE',{type:'add',...v});
```

```
公众号项目中有买商品的功能模块其中增加和减少的按钮是用到vant UI库的组件
在安卓华为一些型号的手机上加号按钮显示有问题，显示的不是+而是-，考虑到兼容性的问题
就单独封装了一个可以加减操作的组件，加号减号用字符写上去，就解决了不同手机上的兼容问题
```

## 28.什么是MVVM

```
// Vue 的核心库只关注视图层

// 什么是MVVM
// M model 模型  (数据)
// V view 视图  (展示)
// C controller 控制器 (数据展示通过控制器)
// viewModel   监控者 (不再需要通过控制器，双向数据绑定)

// Vue.Js的核心
// 1、Vue的数据驱动:
// 数据改变驱动了视图的自动更新

// 2、视图组件化：
// 把整一个网页的拆分成一个个区块，
// 每个区块我们可以看作成一个组件。
// 网页由多个组件拼接或者嵌套组成 
```

## 29.计算属性computed

```
定义：计算属性就是当其依赖属性的值发生变化时，这个属性的值会自动更新，与之相关的DOM部分也会同步自动更新
computed:{ //计算属性 
   getN:function(){
		return this.n-1;
   }	
}
什么时候会用到计算属性呢？
比如：点外卖时会有AB套餐，如果数量大于5份，打8折，否则只能送配送费等这种存在各种计算的处理，计算属性是不错的选择
computed:{ //计算属性
	total(){
		if(this.info.count>5){
			return this.info.price*this.info.count*this.sale+this.freight
		}else {
			return this.info.price*this.info.count +this.freight
		}	
}
```

## 30.计算属性和方法的区别

```
1 ）计算属性是基于它所依赖的数据进行更新，在相关依赖的数据发生变化了才会进行更新，而普通的方法每次都会执行

2） 计算属性是有缓存的，只要它所依赖的数据没有发生改变，后面的每一次访问计算属性中的值，都是之前缓存的结果，不会重复执行。
```

## 31.计算属性和watch的区别

```
1）一个是计算，一个是观察，在语义上是有区别的。
2）计算属性是通过变量计算来得出数据。而观察是观察一个特定的值，根据被观察者的变动进行相应的变化

计算属性只要其它的值变化就会渲染
计算属性就是当其依赖属性的值发生变化时触发
computed: {
	info: function () {
		 return 'computed'+'我的年龄'+this.age + '我的姓名' + this.name
    }
}

watch只有监听的属性才能触发
watch:{
    age:function(newValue, oldValue){
        console.log('ageChange'+'age被修改了', newValue, oldValue);
        this.ageChange = '我的年龄'+newValue +'我的姓名'+ this.name;
    },
    name:function(val) {
    	this.nameChange ='我的姓名'+val +'我的年龄'+ this.age;
    },
}
```

## 32.watch监听

```
定义：watch的作用可以监控一个值的变换,并调用因为变化需要执行的方法
watch:{
    //几种写法 example为监听的名称
    example(curVal,oldVal){
        console.log(curVal,oldVal);
    },
    'example'(curVal,oldVal){
        console.log(curVal,oldVal);
    },
    example:'a',//a表示为methods的方法名
    example:{
        //注意：当观察的数据为对象或数组时，curVal和oldVal是相等的，因为这两个形参指向的是同一个数据对象
        handler(curVal,oldVal){
            console.log(curVal,oldVal)
        },
    	deep:true  //对象内部的属性监听，也叫深度监听
    }

},
```

## 33.Vue的生命周期

```
beforeCreate( 实例创建前 )
created ( 实例创建后 ）
beforeMount ( 实例挂载开始之前被调用 )
mounted ( 实例挂载完成 )
beforeUpdate ( 在数据更新之前被调用 )
updated ( 数据更新后 )
beforeDestroy ( 在实例销毁之前调用，实例仍然完全可用 )
    1. 这一步还可以用this来获取实例，
    2. 一般在这一步做一些重置的操作，比如清除掉组件中的定时器  和 监听的dom事件
destroyed ( 在实例销毁之后调用 )
```

## 34.Vue的 nextTick 

```
将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。$nextTick它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上

常用的场景是在进行获取数据后，需要对新视图进行下一步操作或者其他操作时，发现获取不到dom。因为赋值操作只完成了数据模型的改变并没有完成视图更新
<template>
    <div>
      <button  @click="textChange()" ref="btn">{{text}}</button>
    </div>
</template>
 
<script>
export default {
  data () {
    return {
      text:"原始值",
    }
  },
  methods:{
    textChange:function(){
      this.text="修改值";
      //this.$refs.btn获取指定DOM，输出：原始值
      console.log(this.$refs.btn.innerText);  
      //Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
      this.$nextTick(function(){
        console.log(this.$refs.btn.innerText);  //输出：修改值
      });
    }
  }
}
</script>
```

## 35.什么时候用nextTick

```
Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。

<template>
    <div ref="d">
      <button  @click="textChange()" ref="btn">{{text}}</button>
    </div>
</template>
 
<script>
export default {
  data () {
    return {
      text:"原始值",
    }
  },
  created(){
   //由于DOM还没有生成，不通过this.$nextTick会报错
    this.$nextTick(function(){ 
        var span = document.createElement('span'); //1、创建元素
        span.innerHTML='span新元素';
        this.$refs.d.appendChild(span); //2、找到父在末尾添加元素
    });
  },
  methods:{
    textChange:function(){
      this.text="修改值";
      console.log(this.$refs.btn.innerText);   //this.$refs.btn获取指定DOM，输出：原始值
      this.$nextTick(function(){
        console.log(this.$refs.btn.innerText);  //输出：修改值
      });

    }
  }
}
</script>

//--------------------------------------------------
如果是在dom生成后操作，可以直接

mounted(){
    var span = document.createElement('span'); //1、创建元素
    span.innerHTML='span新元素';
    this.$refs.d.appendChild(span); //2、找到父在末尾添加元素
},
```

## 36.箭头函数的特点

##### 1.箭头函数 语法糖 简化函数的定义

```
	let f = v => v; //变量名 = 参数 = 函数体
    var f = function(v) {
        return v
    }

    //参数为空
    let f = () => 123;
    var f = function() {
        return 123;
    }

    //参数多个
    let f = (n1,n2) => n1+n2;
    var f = function(n1,n2) {
        return n1+n2;
    }
 
    let f = (n1,n2) => {list(n2)};
    var f = function(n1,n2) {
        list(n2);
    }

    var a = [1,2,3,4].filter(function(item){
        return item > 3
    })
    var a = [1,2,3,4].filter(item => item > 3);
```

##### 2.箭头函数不能当做构造函数 不可以使用new命令

```
箭头函数中，this指向固定化，本身是没有自己的this，所以不能作构造函数
	function Fun(name) {
        this.name = 'aaa';
    }
    var f2 = new Fun('name');

    var Fn = () => {
        this.name = 'a';
    }
    var f3 = new Fn(); //Fn is not a constructor
```

##### 3.箭头函数没有原型对象

```
function fun() {}
fun.prototype;

var fun2 = () => {}
fun2.prototype;
```

##### 4.箭头函数不可以使用arguments对象

```
该对象在函数体內不存在
    //替代 rest
    var fun = () => {
        console.log(arguments[1]);
    }
    fun(1,2,3);
```

##### 5.箭头函数里面没有对应的this

```
//由于箭头函数不绑定this，所以它会捕获到所在上下文的this的值，作为自己的this值
//this谁调用指向谁
	var str = 'global';
    var obj = {
        str: 'private',
        getStr: function() {
            console.log(this.str);
        }
    }
    obj.getStr(); //运行者(调用者)为obj，this指向obj
    var a = obj.getStr;
    a(); //运行者(调用者)为window，this指向window
    
	var str = 'global';
    var obj = {
        str: 'private',
        getStr: () => { //绑定的是定义者
            console.log(this.str);
            //箭头函数的表现为getStr的value,它在obj对象中，obj的执行上下文就是window，
            //this.str实际就是window.str 输出'global'
        }
    }
    obj.getStr();
```

## 37.如何确定This指向	this谁调用指向谁

##### 1.简单函数

```
function f() {
	console.log(this); // window
}
f();
```

##### 2.内置函数 

```
setTimeout(f, 1000); // this === window
```

##### 3.回调函数

```
回调函数: 一个函数被作为参数传递给另一个函数 this === window
	function test(v) {
        console.log(v);
    }
    console.log(test); // 整个函数
    console.log(test('hello')); // 调用后的结果

        // (1)
        function f2(callback, v) {
            callback(v);
        }
        f2(test, 'hello');

        // (2) 匿名函数写法
        f2(function(v) {console.log(v)}, 'hello'); // 匿名函数
        f2(function(v) {console.log(this)}, 'hello'); // this === window
        var arr = [1,2,3].filter(function(item, index) {
            console.log(this);
        });
```

##### 4.数组 this的指向看调用者

```
	function f3() {
        console.log(this);
    }
    var arr = [f3, 1, 2, 4];
    arr[0](); // this === arr; . [] 调用者 === arr数组
    var f = arr[0]; // 数组赋值处理后 this指向发生了变化
    f(); // this === window
```

##### 5.对象 this的指向看调用者

```
// (1)简单字面量
        function f3() {
            console.log(this);
        }
        var obj = {};
        obj.id = 123;
        obj.init = function() {
            console.log(this);
        }
        obj.init(); // 调用者obj this === obj
        obj.action = f3;
        obj.action(); // 调用者obj this === obj

// (2)嵌套字面量
        var obj2 = {
            id: 1,
            action: f3
        }
        obj2.action(); // this === obj
```

##### 6.构造函数

```
	function Fun(name, age) {
        this.name = name;
        this.age = age;
        this.action = function() {
            console.log(this);
        }
    }
    var fun2 = new Fun('abc', 13);
    fun2.action(); // this指向的是新创建的对象，而不是构造函数本身
```

## 38.async、await 的优缺点

```
async,await解决异步同步化
async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性

async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。
简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位
```

#### async

##### 1.async异步函数返回的是一个promise对象

```
	async function f() { 
        return 'f'
    }
    f(); //Promise {<fulfilled>: "f"}
```

##### 2.async函数返回的是一个promise对象，如果要获取到promise返回值，应该用then方法

```
	f().then(function (res) { //默认为成功的状态，将该函数的返回值传给then的参数
        console.log(res);
    });

    // 执行顺序
    async function f() {
        return '1234'
    }
    f().then(function (res) {
        console.log(res);
    });
    console.log(1);
    // 1    1234
```

#### await 

##### 1.await操作符用于等待一个Promise对象，它只能在异步函数async function内部使用

```
返回值：
返回promise对象的处理结果，如果等待的不是promise对象，则返回该值本身
如果一个promise被传递给一个await操作符，await将等待promise正常处理完成并返回其处理结果
	function f2() {
        console.log(4);
    }
    async function f() {
        await f2();
        console.log(2);
    }
    f();
    console.log(3);
    //拿到的结果是 4 3 2
    ------------------------------------
    function f2() {
        console.log(4);
    }
    async function f() {
        console.log(1);
        await f2(); //阻塞f()执行，会先执行f2()->执行同步任务->await后面的代码
        console.log(2);
    }
    f();
    console.log(3);
    //拿到的结果是 1 4 3 2
```

##### 2.正常情况下，await命令后面是一个promise对象，它也可以是其它值

```
如字符串，布尔值，数值以及普通函数
	console.log(2)
    async function fn() {
        console.log(3)
        await 100;
        console.log(1)
    }
    fn()
    console.log(4);
    //拿到的结果是 2 3 4 1
--------------------------------------
    function f2() {
        return new Promise((resolve,reject)=>{
            resolve();
            console.log(5);
        })
    }
    async function f() {
        console.log(1);
        await f2();
        console.log(2);
    }
    f();
    console.log(3);
    //拿到的结果是 1 5 3 2
```

## 39.对Promise的理解

Promise定义：Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大

// 解决 JS中多个异步回调难以维护和控制的问题

```
// 回调陷阱：
    $.ajax({
        url:'',
        data:{},
        success:function(data){
            //......
            $.ajax({
                url:'',
                data:{},
                success:function(data){
                    //......
                    $.ajax({
                        url:'',
                        data:{},
                        success:function(data){
                            //......
                        }
                    });
                }
            });
        }
    });
```

基本用法：

// `Promise`对象是一个构造函数，用来生成`Promise`实例
// `Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`
// `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），
// 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
// `reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），
// 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去

// `Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数
// `then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，
// 第二个回调函数是`Promise`对象的状态变为`rejected`时调用。
// 其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数

```
	var p = new Promise(function(resolve, reject){
        if (true) {
            resolve('ok');
        } else {
            reject('error');
        }
    });
    p.then(function(data){
        console.log(data); //成功的
    },function(data){
        console.log(data); //失败
    });
```

#### 多个Promise回调

链式写法 异步同步化

// 解决回调陷阱

```
	var p = new Promise(function(resolve, reject){
        if (true) {
            resolve('ok');
        } else {
            reject('error');
        }
    });
    p.then(function(data){
        console.log(data); //成功的
        return new Promise(function(resolve, reject){
            if (false) {
                resolve(1);
            } else {
                reject(2);
            }
        });
    })
    .then(function(a){
        console.log(a);
    },function(a2){
        console.log(a2);
    })
    .then(function(b){

    })
```

#### 用Promise对象实现的 Ajax

```
	const getJSON = function(url,type, data) {
        const promise = new Promise(function(resolve, reject){ 
          const xmlHttp = new XMLHttpRequest();
          xmlHttp.open(type, url);
          if(type =='get'){
              xmlHttp.send();
          }else {
              xmlHttp.setRequestHeader("Content-Type", "application/json");
              xmlHttp.send(JSON.stringify(data));
          };
          xmlHttp.responseType = "json";
          xmlHttp.onreadystatechange =function(){
            if (xmlHttp.readyState !== 4) return;
            if (xmlHttp.status === 200) {
              resolve(xmlHttp.response);
            } else {
              reject(new Error(xmlHttp.statusText));
            }
          };
        });
        return promise;
    };
```

#### 串行

 //请求一个接口拿到结果后再去发送另一个接口，会等待上一个接口结束后再去执行另一个接口

```
	var p = new Promise(function(resolve, reject){
            if (true) {
                resolve('ok');
            } else {
                reject('error');
            }
        });
        p.then(function(data){
            console.log(data); //成功的
            return new Promise(function(resolve, reject){
                if (true) {
                    resolve(1);
                } else {
                    reject(2);
                }
            });
        },function(data){
            console.log(data); //失败
        })
        .then(function(a){
            console.log(a);
        },function(a2){
            console.log(a2);
        });
```

#### 并行

// 同时请求，一定要等到所有接口都结束了，再往下执行

// Promise.all() 等最后一个结束才返回

// Promise.race() 返回的是请求快的

```
		var p1 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                resolve('p1');
            },1000);
        });
        var p2 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                resolve('p2');
            },5000);
        });
        Promise.all([p1,p2]).then(([d1,d2])=>{
            console.log(d1,d2);
        });

        // 具体写法
        Promise.all([
            getJSON(`${this.url}/get1`,'get').then(res=>{console.log(res)}),
            getJSON(`${this.url}/get2`,'get').then(res=>{console.log(res)}),
        ])
        .then(([d1,d2])=>{
            console.log(d1,d2);
        });

        // Promise.race() 返回的是请求快的
        var p3 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                resolve('p3');
            },1000); 
        });
        var p4 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                resolve('p4');
            },5000); 
        });
        Promise.race([p3,p4]).then(d=>{
            console.log(d);
        });
```

## 40.说说你对闭包的理解

#### 闭包的理解

// 要理解闭包首先要了解js全局变量和局部变量

// JavaScript语言特别之处：函数内部可以直接获取全局变量，函数外部无法获取函数内的局部变量

// 闭包 可以获取到局部变量(说对了一半)

// 闭包的概念：闭包就是能够读取其他函数内部变量的函数

// 由于在js中只有函数内部的子函数才能读取局部变量，所以闭包可以理解成定义在一个函数内部的函数

// 所以本质上闭包是将函数内部和函数外部链接的桥梁

```
	function f1() {
        var a = 10;
        function f2() {
            console.log(a);
        }
        f2();
    }
    f1();
```

#### 为什么需要闭包

// 总结：局部变量无法共享和长久的保存，而全局变量可能造成变量污染

// 当我们希望有一种机制既可以长久的保存变量又不会造成全局污染。

// 局部变量长久保存,不对全局变量污染

```
	function f1() {
        var a = 10;
        a++;
        return a;
    }
    f1(); // 每一次执行f1() 都将重新创建变量a,并没有维持a的状态
    
    var a = 10;
    function f1() {
        a++;
        return a;
    }
    f1(); // a不断变化
```

#### 闭包写法

```
	function f1() {
        var a = 10;
        function f2() {
            a++;
            console.log(a);
        }
        return f2;
    }
    // console.log(f1());
    // f1()();
    
    var f = f1(); // f就是闭包
    //相当于把f1执行的结果赋给了一个全局变量f
    //导致f2始终在内存中没有回收，f2依赖于f1，所以f1不会在调用后回收
    f();
```

##### 闭包另一种写法

```
	function f1() {
        var a = 10;
        return function() {
            a++;
            console.log(a);
        }
    }
```

#### 垃圾回收

//相当于把f1执行得结果赋给了一个全局变量

//导致f2始终在内存中没有回收，f2依赖于f1，所以不会在调用后回收

//定义一个全局变量存在window，局部变量在函数调动时被创建，

//函数调动后变量会被释放销毁，希望这个值被长久保存就是把这个值放在全局变量下

```
	function f1() {
        var a = 10;
        a++;
        return a;
    }
    var f11 = f1;
    f11(); // 相当于重新执行f1
```

实际作用：

//对象封装 name缓存

```
	function Person() {
        var name = 'abc';
        return {
            getName: function() {
                return name;
            },
            setName: function(newname) {
                name = newname;
            }
        }
    }
    var person = Person();
    person.getName();
    //改变name
    person.setName('aaa');
    person.getName();
```

//另一种写法

```
	var person = function() {
        var name = 'abc';
        return {
            getName: function() {
                return name;
            },
            setName: function(newname) {
                name = newname;
            }
        }
    }();
    person.getName();
```

经典面试题，循环中使用闭包解决 `var` 定义函数的问题

```
for ( var i=1; i<=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
```

首先因为 `setTimeout` 是个异步函数，所有会先把循环全部执行完毕，这时候 `i` 就是 6 了，所以会输出一堆 6。

解决办法两种，第一种使用闭包

```
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

第二种就是使用 `setTimeout` 的第三个参数

```
for ( var i=1; i<=5; i++) {
	setTimeout( function timer(j) {
		console.log( j );
	}, i*1000, i);
}
```

第三种就是使用 `let` 定义 `i` 了

```
for ( let i=1; i<=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
```

## 41.基本数据类型和引⽤类型在存储上的差别

```
前者存储在栈上，后者存储在堆上
基础类型：
    string number null Boolean Undefined
引用类型：
    array object function
```

## 42.说说函数节流和防抖

防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的情况会每隔一定时间（参数wait）调用函数。

我们先来看一个袖珍版的防抖理解一下防抖的实现：

```
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}
// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数
```

下面我们来实现一个带有立即执行选项的防抖函数

```
// 这个是用来获取当前时间戳的
function now() {
  return +new Date()
}
/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
function debounce (func, wait = 50, immediate = true) {
  let timer, context, args
  
  // 延迟执行函数
  const later = () => setTimeout(() => {
    // 延迟函数执行完毕，清空缓存的定时器序号
    timer = null
    // 延迟执行的情况下，函数会在延迟函数中执行
    // 使用到之前缓存的参数和上下文
    if (!immediate) {
      func.apply(context, args)
      context = args = null
    }
  }, wait)

  // 这里返回的函数是每次实际调用的函数
  return function(...params) {
    // 如果没有创建延迟执行函数（later），就创建一个
    if (!timer) {
      timer = later()
      // 如果是立即执行，调用函数
      // 否则缓存参数和调用上下文
      if (immediate) {
        func.apply(this, params)
      } else {
        context = this
        args = params
      }
    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个
    // 这样做延迟函数会重新计时
    } else {
      clearTimeout(timer)
      timer = later()
    }
  }
}
```

## 43.typeof 于 instanceof 区别

#### typeof

`typeof` 对于基本类型，除了 `null` 都可以显示正确的类型

```
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof b // b 没有声明，但是还会显示 undefined
```

typeof` 对于对象，除了函数都会显示 `object

```
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```

对于 `null` 来说，虽然它是基本类型，但是会显示 `object`，这是一个存在很久了的 Bug

```
typeof null // 'object'
```

#### instanceof

instanceof用来检测某个对象是不是另一个对象的实例

官方的话：该运算发用来测试一个对象在其原型链中是否存在一个构造函数prototype属性

```
var a = new Array();

console.log(a instanceof Array);    // 会返回 true
console.log(a instanceof Object);    // 也会返回 true

因为Array是object 的子类
```

另外，更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型

```
function Foo(){} 
Foo.prototype = new Aoo();//JavaScript 原型继承 
var foo = new Foo(); 
console.log(foo instanceof Foo)//true 
console.log(foo instanceof Aoo)//true

上面的代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。

又如：
console.log(Object instanceof Object);//true 
console.log(Function instanceof Function);//true 
console.log(Number instanceof Number);//false 
console.log(String instanceof String);//false  
console.log(Function instanceof Object);//true  
console.log(Foo instanceof Function);//true 
console.log(Foo instanceof Foo);//false
```

```
// 定义构造函数
function C(){} 
function D(){} 

var o = new C();

// true，因为 Object.getPrototypeOf(o) === C.prototype
o instanceof C; 

// false，因为 D.prototype不在o的原型链上
o instanceof D; 

o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true
C.prototype instanceof Object // true,同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true
```

## 44.Vue 的父子通信

```

```

## 45.简述路由原理

```
1.前端路由实现起来其实很简单，本质就是监听URL的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式

hash 模式 ---- 利用URL中的hash（“#”）
www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面

history 模式 ---- 利用History interface在 HTML5中新增的方法
History 模式是 HTML5 新推出的功能，比之 Hash URL 更加美观


2.在vue-router中，它提供mode参数来决定采用哪一种方式，选择流程如下:

mode:'hash' ，多了 “ # ”
http://localhost:8080/#/recommend

mode:'history'
http://localhost:8080/recommend
```

## 46.微任务和宏任务

宏任务 setTimeout  setInterval setTimeout

微任务 promise中的then async await

```
// 微任务与宏任务的区别
就像去银行办业务一样，先要取号进行排号。
一般上边都会印着类似：“您的号码为XX，前边还有XX人。”之类的字样。
由于柜员只能处理一个来办理业务的客户，这时每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的；
当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。
所以多个宏任务合在一起就可以认为有一个任务队列在这，里边是当前银行中所有排号的客户。
如果叫到你的时候你不在，那么你当前的号牌就作废了，柜员会选择直接跳过进行下一个客户的业务处理，等你回来以后还需要重新取号

而且一个宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，你前边的一位老大爷可能在存款，结果在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务，这时老大爷想了一下：“想选择稳一些的理财”，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。
所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。
也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？
无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。
在当前的微任务没有执行完成时，是不会执行下一个宏任务的。
```

#### Promise本身是同步的

同步是非得等所有的执行完了，才往下执行

异步是执行的时候可以同时执行别的

```
	console.log(1);
    let a = new Promise((resolve, reject) => {
        console.log(2);
    });
    console.log(3);
    let b = new Promise((resolve, reject) => {
        console.log(4);
    });
    console.log(5);
    // 拿到的结果是 1 2 3 4 5
```

#### Promise本身是同步的，他的then方法和catch方法是异步的

```
	let a = new Promise((resolve, rej) => {  //同步
        console.log(1);
        resolve(3)
    });
    a.then((res) => {    //微任务
        console.log(res);
    });
    console.log(2);  //同步
    //拿到的结果是 1 2 3
```

###### 扩展实例1

```
	console.log(1) //同步
    let a = new Promise((res, rej) => {
        res();
        console.log(2); //同步
    });
    a.then(() => {
        console.log(3) //异步
    })
    console.log(4); //同步
    let b = new Promise((res, rej) => {
        res();
        console.log(5); //同步
    });
    b.then(() => {
        console.log(6) //异步
    })
    console.log(7); //同步
    //拿到的结果是 1 2 4 5 7 3 6
```

###### 扩展实例2

```
	setTimeout(()=>{ //宏任务
        console.log(1);
    },0);
    new Promise((resolve,reject)=>{
        resolve();
        console.log(2); //同步
    }).then(()=>{
        console.log(3); //微任务 异步
    });
    //拿到的结果是 2 3 1
```

###### 扩展实例3

```
	setTimeout(()=>{ //宏任务
        console.log(1);
    },0);
    new Promise((resolve,reject)=>{
        resolve();
        console.log(2); //同步
    }).then(()=>{
        console.log(3); //微任务 异步
    });
    console.log(4); //同步
    //拿到的结果是 2 4 3 1
```

###### 扩展实例4

```
	async function f() {
        console.log(5); //同步
        return '1234'
    }
    f().then(res=>{ //微任务 异步
        console.log(res);
    });
    console.log(1); //同步
    //拿到的结果是 5 1 1234
```

## 47.http三次握手

```
第一次握手：客户端给服务器端发送一个syn的标志位；服务器端接收到syn后会返回一个ack(相当于一个回调的机制)，同时还有一个服务器端的syn；客户端接收服务器端发送的syn后会再次给服务器端发送一个ack，这样才算完成三次握手

客户端问服务端有没有空接收数据，服务端收到响应回复可以，客户端数据已发送，服务端收到接收数据
```

## 48.http四次分手

```
客户端向服务器端发送断开连接的请求；服务器端接收到请求后，返回可以断开连接的请求，客户端断开连接并且释放资源；服务器端向客户端发送断开连接的信息；客户端向服务器端发送同意断开连接的信息，服务器端断开连接释放资源

客户端向服务器端发送断开连接的请求,服务器端接收到请求后服务端等待数据传送完后,服务器端向客户端发送可以断开连接的信息,
客户端向服务器端发送已经断开的信息，服务器端收到客户端断开的通知，然后服务端也断开连接
```

## 49.http协议规范

```
HTTP协议是一个规范。一定会限制请求的格式。
http协议的请求格式分为3个部分：请求行、请求头、请求体。
```

##### 请求行

```
包括三个属性。描述对应的请求的时候，最精确的形式就是K-V键值对的格式。
请求头中也是一堆的K-V数据。包含头信息中的一些附加信息(比如客户端允许接收的信息格式)。
```

##### 请求头

```
提供了关于请求,响应或者其他的发送实体的信息

Content-Type

- text/plain 纯文本
- application/x-www-form-urlencoded 指定内容类型为键值对
- application/octet-stream 二进制流数据
- application/json  json数据格式
- multipart/form-data  formdata表单数据格式
```

##### 请求体

```
当发送某一个请求的时候，请求后面可以加一些用户定义的参数(比如表单)。以K=V的形式发送给后台。
```

## 50.http与https区别

```
https比http多了一层加密处理
```

## 51.跨域

##### 什么是跨域

```
跨域是指从一个域名的网页去请求另一个域名的资源。比如从www.baidu.com 页面去请求 www.google.com 的资源。跨域的严格一点的定义是：只要协议，域名，端口有任何一个的不同，就被当作是跨域。
```

##### 为什么浏览器要限制跨域访问呢？

```
原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。
```

##### 为什么要跨域（从一个页面引用其它页面的资源）

```
既然有安全问题，那为什么又要跨域呢？有时公司内部有多个不同的子域，比如一个是location.company.com ,而应用是放在app.company.com , 这时想从 app.company.com去访问 location.company.com 的资源就属于跨域
```

##### 跨域解决方案

```
- cors 后端 适合开发打包和上线
- nginx 代理中间件 代理是转发请求
- jsonp
```

###### cors

```
app.use(function (req, res, next) {
 res.setHeader('Access-Control-Allow-Origin', '*');
 res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE');
 res.setHeader('Access-Control-Allow-Headers', '*');
 next();
});
```

###### nginx

Windows: 下载nginx.zip, 在nginx目录查找nginx.conf文件并添加以下内容

Mac: open -t /usr/local/etc/nginx/nginx.conf

mac默认ng端口8080

关于Mac下操作：

`brew services start nginx`

`brew services stop nginx`

```
server {
		listen       8089; 服务监听端口
		server_name  localhost; 主机IP
		root   html;    #根目录
		# cors
		add_header Access-Control-Allow-Origin $http_origin always;  # '*' 
		add_header Access-Control-Allow-Credentials true always;
		add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS' always;
		add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization' always;

		#请求http://localhost:8080/api，将该请求转发到http://localhost:3000/api
		location /api {
			proxy_pass http://localhost:3000/api;
		}
	}
```

###### jsonp

```
app.get("/api/jsonp", function(req, res){
    var data = {name: "jsonp数据"}
    data = JSON.stringify(data); //转字符串
    var callback = `${req.query.callback}(${data})`; //函数名+数据
    console.log(callback)
    res.send(callback);
})
function getJsonp() {
    $.ajax({
      url: "http://localhost:3000/api/jsonp",
      data: {name: "xxxx"},
      dataType: "jsonp",
      jsonpCallback: "handleResponse"
    })
};
function handleResponse(data) {
    console.log(data);
}
```

## 52.什么是Node

```
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时

#### 开发框架

- Express 快速、开放、极简的 Web 开发框架。
- Koa 下一代 web 开发框架。
- Egg 为企业级框架和应用而生。

#### 启动node服务

创建包文件：npm init

安装依赖：npm i -S express body-parser

启动：node xxx.js

停止：ctrl+c
```

```
## 路由配置
1. 把路由单独抽离 动态加载所有路由
2. 在路由中绑定控制器对应方法

## 控制器
1. 控制器主要是分离业务逻辑

## 后端服务的分层
路由--将请求跳转到对应的控制层
控制层--对参数进行检查校验，不合格直接返回错误
服务层--拿参数进行业务处理，查询，统计等
ORM数据访问层/sql--去数据库取数据

数据访问的方式：
ORM--通过js对象的方式访问数据,不需要写sql
sql--通过写脚本的方式查询数据

## ORM数据访问框架-sequelize
需要数据模型对象去访问数据
数据模型对象--数据库表 一一对应

## 创建模型对象
可以通过脚本的方式自动生成所有的数据模型对象
脚本里面需要配置数据库的连接
127.0.0.1--本机
localhost--本机
npm install -g sequelize-auto mysql2
win: cmder/git bash  sh sequelize-model.sh
mac: sh sequelize-model.sh
注意：若脚本文件是从win机器上创建的，在mac上执行会有问题 dos2unix *.sh

## 加载模型对象
在modules下创建index.js 用于加载所有模型文件
其它模块需要使用模型时，只需引入index
cnpm i -S sequelize mysql mysql2

## 创建服务层
使用模型对象访问数据

## 创建控制层
使用服务层对象访问数据
```

## 53.cookie(浏览器)--session(服务器)

```
cookie---5k
默认id xxxxx   登录成功后   yyyyyy
小王--------->浏览器---------->京东网站
小张--------->

通过会话cookie--session识别不同用户

登录后服务端分配的cookie id 和 session id是绑定关系吗？还是说本来就是一个id
登录成功--生成新sessionid--返回浏览器并设置到cookieid

chrome >=80版本 http协议下不再携带cookie https下支持
chrome也有开关 测试环境下可以关闭该功能，让带上cookie
小程序  线上环境一定是https  测试环境可以是http(开关)
```

## 54.cookie和localSrorage、session、indexDB 的区别

| 特性         | cookie                                     | **localStorage**         | sessionStorage | indexDB                  |
| ------------ | ------------------------------------------ | ------------------------ | -------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间         | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K                                         | 5M                       | 5M             | 无限                     |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与                   | 不参与         | 不参与                   |

从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

## 55.简单说下原型链

```
每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。
每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 _proto_ 来访问。
对象可以通过 __proto__ 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链。
```

## 56.怎么判断对象类型

```
可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。
instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。
```

## 57.CSS3 transform介绍

```
https://www.jianshu.com/p/17e289fcf467
transform本质上是一系列变形函数，分别是translate位移，scale缩放，rotate旋转，skew扭曲，matrix矩阵

前置属性：
transform-origin
transform-style
perspective
perspective-origin
backface-visibility
2D变形：
translate
scale
rotate
skew
matrix
3D变形：
translate3d
scale3d
rotate3d
matrix3d
层级影响

translate位移 (蠢死累特)
translate位移系列中用于2D的有：translate，translateX，translateY
```

## 58.let 与 var

```
// 声明提升
console.log(name);
var name = '小猪';
// let name = '小狗'; 报错

// 变量覆盖
var a = '小红';
var a = '小绿';
// let a = '小黄' 报错
console.log(a);

// var 没有块级作用域
function fn() {
   for(var i=0; i<5; i++) {}
   // for(let i=0; i<5; i++) {} 报错
   console.log(i);
}
fn();
```

## 59.深度剖析JS闭包

##### 闭包的理解

1. 是形成不销毁的私有作用域
2. 访问其他函数内部变量的函数
3. 一个外部函数可以访问另一个函数内部局部变量称为闭包

```
// 全局变量
let a = '诗酒趁年华';
function fn1() {
  let b = 1;
  console.log(a);
}
// console.log(b);
fn1();
```

##### 回收机制

- 局部变量会被垃圾回收机制回收掉
- 全局变量不会被回收
- 上述代码fn1执行完后b变量会被销毁
- AO active object 临时变量对象

##### 闭包应用场景

事件防抖和节流

防抖和节流的区别：

- 防抖：防抖是短时间多次触发只执行一次		一定的时间内只允许一个事件
- 节流：多次变为一次

```
	<input placeholder=""/>
	
	function antiShake(fn, wait) {
            // 一辆赛车
            let timeOut = null;
            return function() {
                if (timeOut) {
                    // 有赛车就销毁
                    clearTimeout(timeOut);
                } else {
                }
                // 放入一辆赛车
                timeOut = setTimeout(fn, wait);
            }
            // return args => {
            //     if (timeOut) clearTimeout(timeOut)
            //     timeOut = setTimeout(fn, wait)
            // }
        }
        function demo() {
            console.log('我要请求数据');
        }
        let telInput = document.querySelector("input");
        telInput.addEventListener('input', antiShake(demo, 1000));
```

##### 模块化

##闭包提供了面向对象编程的好处 —— 数据的隐藏和封装

```
	// 面向对象编程
        let makeCounter = function() {
            let privateCounter = 0; //有自己的私有变量
            function changeBy(val) { //有自己的方法
                privateCounter += val;
            }
            return {
                add: function() {
                    changeBy(1);
                },
                reduce: function() {
                    changeBy(-1);
                },
                value: function() {
                    return privateCounter;
                }
            }
        }
        // 每个counter1，counter2都有自己的私有变量和方法
        let counter1 = makeCounter();
        let counter2 = makeCounter();

        counter1.add();
        counter1.add();

        // 词法作用域
        counter2.add();
        counter2.reduce();

        console.log(counter1.value()); // 2
        console.log(counter2.value()); // 0
```

## 60.原型链与继承

```
		// 构造函数：看是否用它创建实例
        var age = 20;
        function Person(){
            // this.name = 'aaa'
        }
        Person.prototype.name = '小明';
        Person.prototype.age = 18;
        Person.prototype.getAge = function() {
            console.log(this.age); // 18
            console.log(this.name); // 小明
        }
        var person1 = new Person();

        // person1会继承到父，Person {name: "aaa"} 以及原型链上的方法和属性
        console.log(person1); // Person {name: "aaa"}
        // console.log(person1.getAge());

        // person1.name = '字节';
        console.log(person1.name); // 字节 就近原则
```

##### constructor 构造器

指向哪里: 指向构造他的函数

```
// constructor: 构造器 指向哪里: 指向构造他的函数
console.log(person1.constructor);
// Person(){
//     this.name = 'aaa'
// }
```

##### 原型链查找规则

- 自下而上
- 沿着原型链  _proto_   一层一层的往上找，直到null为止，如果没有找到报未定义
- null => Object, Array(基类) => {} []

##### 实例的原型链指向了构造他函数的原型

```
		person1.a = '基本属性';
        console.log(person1);
        // hasOwnProperty 判断是基本属性还是私有属性
        let item;
        for(item in person1) {
            if(person1.hasOwnProperty(item)) {
                console.log(item);
            }
        }
```

## 61.递归

递归，就是在运行的过程中调用自己 (无限极使用递归)

```
	function f() {
        console.log('f');
        f(); // 递归自调
    }
    f();
```

添加结束条件

```
	var i = 0;
    function f1() {
        i++;
        console.log(i);
        if (i < 5) {
            f1();
        }
    }
    f1();
```

递归原理

```
	//5+4+3+2+1
    function getNum(n) {
        if(n>=1) {
            return n+getNum(n-1);
        }
        return 0;
    }
    getNum(5);
    //执行顺序
    // 1.getNum(5)---if成立---5+---getNum(5-1) 自调
    // 2.getNum(4)---if成立---4+---getNum(4-1) 自调
    // 3.getNum(3)---if成立---3+---getNum(3-1) 自调
    // 4.getNum(2)---if成立---2+---getNum(2-1) 自调
    // 5.getNum(1)---if成立---1+---getNum(1-1) 自调
    // 6.getNum(0)---if不成立
```

## 62.class类

es6 语法糖 语法规范 代码更加简洁清晰

ES6 的class类，完全可以看作构造函数的另一种写法

```
	// es5
    function Point(x, y){
        this.x = x;
        this.y = y;
    }
    Point.prototype.toString = function() {
        return this.x
    }
    var p = new Point(2,4);
    p.x;
    p.toString();
```

```
    // es6
	class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        toString() {
            return this.x
        }
    }
    var p2 = new Point(2,4);
    p2.x;
    p2.toString();
```

上面代码定义了一个“类”，可以看到里面有一个`constructor`方法，这就是构造方法，而`this`关键字则代表实例对象。也就是说，ES5 的构造函数`Point`，对应 ES6 的`Point`类的构造方法

`Point`类除了构造方法，还定义了一个`toString`方法。注意，定义“类”的方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。 另外，方法之间不需要逗号分隔，加了会报错

##### constructor方法

`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加

```
	class Point {
    }
    
    // 等同于
    class Point {
      constructor() {}
    }
```

##### Class类的继承

Class可以通过`extends`关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多

```
	class A {
        constructor() {
            this.a = 'a';
        }
    }

    class B extends A { //表示通过exends关键字，继承A类所有的属性和方法
        constructor() {
            // 子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错
            super(); //表示父类的构造函数
            this.b = 'b';
        }
    }

    var a = new A();
    var b = new B();
    b.a
```

##### super关键字

`super`这个关键字，既可以当作函数使用，也可以当作对象使用

`super`作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次`super`函数

```
	class A {}

    class B extends A {
      constructor() {
        super();
      }
    }
    // 子类B的构造函数之中的super()，代表调用父类的构造函数。
    // 这是必须的，否则 JavaScript 引擎会报错
```

扩展

```
	class A {
        constructor(x,y) {
            this.x = x;
            this.y = y;
        }
        toString() {
            return this.x
        }
    }

    class B extends A { //表示通过exends关键字，继承A类所有的属性和方法
        constructor(x,y,b) {
            super(x,y); //表示父类的构造函数
            this.b = b;
        }
    }

    var b = new B('333','444','abc');
    b.x;
```

## 63.Proxy

Proxy是一个代理，响应式数据发生变化的时候中间拦截，修改数据再获取

```
var p = new Proxy(target, handler);
// 生成p实例
// target表示所要拦截的目标对象，
// handler对象发生改变，用来定制拦截行为

var target = {};
var handler = {};
var p = new Proxy(target, handler);
// handler 是一个空对象，没有任何拦截行为，访问p就是等同于访问target
```

```
	var target = {
        name: '华哥'
    }
    var handler = {
        get:(target,key)=>{
            return 'tom'
            // return target
        }
    }
    var p = new Proxy(target, handler);
    p.name;
```

```
	var target = {
        name: 'jindu'
    }
    var handler = {
        get: function(target, key) {
            console.log(`${key}被读取`);
            return target[key];
        },
        set: function(target, key, value, receiver) { //原对象 键 值 实例对象
            console.log(`${key}被设置为${value}`);
            target[key] = value;
        }
    }
    var a = new Proxy(target, handler);
    a.name; // 控制台输出：name 被读取
    a.name = 'abc'; // 控制台输出：name 被设置为 abc
    console.log(target.name); // 控制台输出: abc
    
    // a读取属性的值时，实际上执行的是 handler.get：在控制台输出信息，并且读取被代理对象 `target` 的属性
    // 在 a 设置属性值时，实际上执行的是 handler.set：在控制台输出信息，并且设置被代理对象 `target` 的属性的值	
```

##### Proxy场景

1）实现私有变量，想获取angelababy，由于添加了拦截获取的只能是18

```
	var angelababy = {
        name: 'angelababy',
        _age: 30
    }
    var handler = {
	    //get方法有三个参数 目标对象，属性名，属性值
        get:(target, key)=>{
            if(key.startsWith('_')) { //startsWith() 用于检测字符串是否以指定的某一个字符串开始的
                return 18
            }
            return target[key];
        },
        //set方法有四个参数 目标对象，属性名，属性值，proxy实例本身(非必需)
        set:(target, key, value)=>{
            if(key.startsWith('_')) {
                return 18
            }
            target[key] = value
        }
    }
    var a = new Proxy(angelababy, handler);
    a._age;
    a._age = 100;
```

2）抽离校验模块

```
	var num = {
        count: 0,
        id: 1234,
        total: 14
    };
    var handler = {  
        set(target, key, value, proxy) {
            if (typeof value !== 'number') {
                throw Error("只能输入数字");
            }
            return Reflect.set(target, key, value, proxy); 
        }
    };
    var p = new Proxy(num, handler);
    // 抛出错误，因为 "123" 不是数值型
    p.count = "123";
    // 赋值成功
    p.count = 333;
```

##### Object.defineProperty()与Proxy的异同

vue2.0和3.0的区别:

对于数据拦截

- vue2.0 使用Object.defineProperty()
- vue3.0 使用Proxy

响应式的数据是只要数据发生变化的时候响应式的数据处理，拦截的行为

###### Object.defineProperty()

- 优点：可以更好的拦截
- 缺点：无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应(虽说对常用的方法进行了处理，但然存在局限性)；只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。

```
	var Obj = {
        a: ''
    };
    Object.defineProperty(Obj, 'a', {
        get: function() {
            console.log('get');
            return v
        },
        set: function(val) {
            console.log('set');
            v = val;
        }
    });
    Obj.a = 123;
```

###### Object.defineProperty 对数组有局限性无法达到响应式

```
	var Obj = {}
    Object.defineProperty(Obj, 'a', {
        get: function () {
            console.log('get');
            return v
        },
        set: function (val) {
            console.log('set');
            v = val
        }
    });
    Obj.a = [] // set 
    Obj.a.push('1') // get 
    Obj.a[0] = 1 // get
    Obj.a.pop(1) // get 
    Obj.a = [1, 2, 3] // set
```

###### proxy

- 优点：可以劫持整个对象，并返回一个新对象；有13种劫持操作
- 缺点：兼容性不好

```
	var arr = [];
    var p = new Proxy(arr, {
        get: (target, key) => {
            console.log('get')
            return key in target ? target[key] : undefined
        },
        set: (target, key, value) => {
            console.log('set')
            target[key] = value
            return true
        }
    })
    p.push(1);
    get  // 获取数组arr的push方法
    get  // 获取数组arr的length属性
    set  // 设置arr[0] = 1
    set  // 设置数组arr长度为1
```

## 64.css元素水平垂直居中

##### 水平方向上

```
针对inline, 内联块inline-block, 内联表inline-table, inline-flex元素及img,span,button等元素
.text_div{
	text-align:center;
}
```

```
不定宽块状元素居中
.text_div{
    margin:0 auto;//且需要设置父级宽度
}
```

```
通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。
.wrap{
    float:left;
    position:relative;
    left:50%;
    clear:both;
}
.wrap-center{
    left:-50%;
}
```

##### 垂直居中

垂直居中的方法，如果全写出来，有10多种。面试的时候一般都会说比较常用的几种。`flex`、`position + transform`、`position + 负margin`是最常见的三种情况

```
<div class="outer">
    <div class="inner"></div>
</div>
```

###### **方法一：flex**

```
.outer{
    display: flex;
    justify-content: center;
    align-items: center
}
```

###### **方法二： position + transform, inner宽高未知**

```
.outer{
    position:relative;
}
.inner{
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
}
```

###### **方法三：position + 负margin, inner宽高已知**

```
.outer{
    position: relative;
}
.inner{
    width: 100px;
    height: 100px;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
```

## 65.css盒模型

盒模型感觉是刚学前端的时候就会接触到的问题。元素都是按照盒模型的规则布局在页面中的。盒模型由 `margin + border + padding + content` 四个属性组成，分为两种：W3C的标准盒模型和IE盒模型

##### W3C的标准盒模型

```
width = content，不包含 border + padding
```

##### IE盒模型

```
width = border + padding + content
```

##### 相互转换

```
二者之间可以通过CSS3的 box-sizing 属性来转换。

box-sizing: content-box 是W3C盒模型

box-sizing: border-box 是IE盒模型
```

各种获得宽高的方式

```
获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width
获取屏幕工作区域的高度和宽度（去掉状态栏）：window.screen.availHeight/availWidth
网页全文的高度和宽度：document.body.scrollHeight/Width
滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft
网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth
网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth
```

## 66.html5语义化

意义：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。

```
注意：
1.尽可能少的使用无语义的标签div和span；
2.在语义不明显时，既可以使用div或者p时，尽量用p,因为p在默认情况下有上下间距，对兼容特殊终端有利；
3.不要使用纯样式标签，如：b、font、u等，改用css设置。
4.需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
5.使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
6.表单域要用fieldset标签包起来，并用legend标签说明表单的用途；
7.每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。
```

## 67.清除浮动的方法

不清楚浮动会发生高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷）

清除浮动主要是为了防止父元素塌陷。清除浮动的方法有很多，常用的是 `clearfix` 伪类。

##### **方法一：clearfix**

```
<div class="outer clearfix">
    <div class="inner">inner</div>
</div>
.outer{
    background: blue;
}
.inner{
    width: 100px;
    height: 100px;
    background: red;
    float: left;
}
.clearfix:after{
    content: "";
    display: block;
    height: 0;
    clear:both;
    visibility: hidden;
}
```

##### **方法二：额外加一个div，clear:both**

```
<div class="container">
    <div class="inner"></div>
    <div class="clear"></div>
</div>
.container{
    background: blue;
}
.inner {
    width: 100px;
    height: 100px;
    background: red;
    float: left;
}
.clear{
    clear:both;
}
```

##### **方法三：触发父盒子BFC，overflow:hidden**

```
<div class="outer">
    <div class="inner">inner</div>
</div>
.outer{
    background: blue;
    overflow: hidden;
}
.inner {
    width: 100px;
    height: 100px;
    background: red;
    float: left;
}
```

## 68.如何用css实现一个三角形

##### **方法1： 利用border属性**

利用盒模型的 border 属性上下左右边框交界处会呈现出平滑的斜线这个特点，通过设置不同的上下左右边框宽度或者颜色即可得到三角形或者梯形。

```
.triangle {
    height:0;
    width:0;
    border-color:red blue green pink;
    border-style:solid;
    border-width:30px;
}
```

![img](https://user-gold-cdn.xitu.io/2019/10/13/16dc5881277c896c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如果想实现其中的任一个三角形，把其他方向上的 `border-color` 都设置成透明即可。

```
.triangle {
    height:0;
    width:0;
    border-color:red transparent transparent transparent;
    border-style:solid;
    border-width:30px;
}
```

![img](https://user-gold-cdn.xitu.io/2019/10/13/16dc58ad2033b4be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

##### **方法二： 利用CSS3的clip-path属性**

```
.triangle {
    width: 30px;
    height: 30px;
    background: red;
    clip-path: polygon(0px 0px, 0px 30px, 30px 0px); // 将坐标(0,0),(0,30),(30,0)连成一个三角形
    transform: rotate(225deg); // 旋转225，变成下三角
}
```

## 69.animation

![img](https://user-gold-cdn.xitu.io/2018/9/9/165bd6dede39a8b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

------

## 70.display相关

```
block:div等容器类型
inline:img span等行内类型
table系列：将样式变成table类型
flex:重点把握，非常强大
grid:同上
inline-block:可设置宽度，两者间有一点间隙
inherit:继承父级
```

## 71.CSS权重计算方式

CSS基本选择器包含ID选择器、类选择器、标签选择器、通配符选择器。 正常情况下，

一般都能答出`!important > 行内样式 > ID选择器 > 类选择器 > 标签选择器 > 通配符选择器`。

##### **各选择器权值：**

```
内联样式，权值为1000
ID选择器，权值为0100
类，伪类和属性选择器，权值为0010
标签选择器和伪元素选择器，权值为0001
通配符、子选择器、相邻选择器等，权值为0000
继承的样式没有权值
```

##### **比较方式：**

```
如果层级相同，继续往后比较，如果层级不同，层级高的权重大，不论低层级有多少个选择器
```

## 72.如何实现一个自适应的正方形

##### **方法1：利用CSS3的vw单位**

`vw` 会把视口的宽度平均分为100份

```
.square {
    width: 10vw;
    height: 10vw;
    background: red;
}
```

##### **方法2：利用margin或者padding的百分比计算是参照父元素的width属性**

```
.square {
    width: 10%;
    padding-bottom: 10%; 
    height: 0; // 防止内容撑开多余的高度
    background: red;
}
```

## 73.三栏布局

三栏布局是很常见的一种页面布局方式。左右固定，中间自适应。实现方式有很多种方法。

##### **第一种：flex**

```
<div class="container">
    <div class="left">left</div>
    <div class="main">main</div>
    <div class="right">right</div>
</div>
.container{
    display: flex;
}
.left{
    flex-basis:200px;
    background: green;
}
.main{
    flex: 1;
    background: red;
}
.right{
    flex-basis:200px;
    background: green;
}
```

##### **第二种：position + margin**

```
<div class="container">
    <div class="left">left</div>
    <div class="right">right</div>
    <div class="main">main</div>
</div>
body,html{
    padding: 0;
    margin: 0;
}
.left,.right{
    position: absolute;
    top: 0;
    background: red;
}
.left{
    left: 0;
    width: 200px;
}
.right{
    right: 0;
    width: 200px;
}
.main{
    margin: 0 200px ;
    background: green;
}
```

##### **第三种：float + margin**

```
<div class="container">
    <div class="left">left</div>
    <div class="right">right</div>
    <div class="main">main</div>
</div>
body,html{
    padding:0;
    margin: 0;
}
.left{
    float:left;
    width:200px;
    background:red;
}
.main{
    margin:0 200px;
    background: green;
}
.right{
    float:right;
    width:200px;
    background:red;
}
```

## 74.forEach，map和filter的区别

```
forEach遍历数组，参数为一个回调函数，回调函数接收三个参数，当前元素，元素索引，整个数组；
map与forEach类似，遍历数组，但其回调函数的返回值会组成一个新数组，新数组的索引结构和原数组一致，原数组不变；
filter会返回原数组的一个子集，回调函数用于逻辑判断，返回true则将当前元素添加到返回数组中，否则排除当前元素，原数组不变。
```

## 75.理解深拷贝和浅拷贝

```
浅拷贝:
是指创建一个对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，那么拷贝的就是基本类型的值，如果属性是引用类型，那么拷贝的就是内存地址，所以如果其中一个对象修改了某些属性，那么另一个对象就会受到影响。

深拷贝:
是指从内存中完整地拷贝一个对象出来，并在堆内存中为其分配一个新的内存区域来存放，并且修改该对象的属性不会影响到原来的对象。
```

```
浅拷贝：
将对象中的所有字段复制到新的对象中。其中，值类型字段被复制到新对象中后，在新对象中的修改不会影响到原先对象的值。而新对象的引用类型则是原先对象引用类型的引用，不是引用自己对象本身

深拷贝：
同样也是拷贝，但是与浅拷贝不同的是，深拷贝会对引用类型重新在创新一次(包括值类型)，在新对象做的任何修改都不会影响到源对象本身
```

```
浅拷贝: 只是拷贝了指针，使得两个指针指向同一个地址

深拷贝: 采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂
```

## 76.深拷贝和浅拷贝的实现方式分别有哪些

```
浅拷贝：(1) Object.assign的方式 (2) 通过对象扩展运算符 (3) 通过数组的slice方法 (4) 通过数组的concat方法。
深拷贝：(1) 通过JSON.stringify来序列化对象 (2) 手动实现递归的方式。
```

## 77.大概说下实现无缝轮播的思路

```
先简单说了下实现轮播的思路，多张图片从左至右依次排列，点击左右侧按钮切换图片的时候，让图片的父级容器的left偏移值增加或减少单张图片的宽度大小，同时配合CSS3 transition过渡或者手写一个动画函数，这样可以实现一个比较平滑的动画效果。对于无缝轮播，我当时的思路是再拷贝一个图片的父级容器出来，例如原来一个<ul><li></li><li></li></ul>对应两张图片，现在变为两个ul对应4张图片，同时ul的父容器监听自身的scrollLeft，如果值已经大于等于一个ul的宽度，则立即将自身的scrollLeft值重置为0，这样就又可以从起点开始轮播，实现无缝的效果。
```

## 78.git多人协作时如何解决冲突

```
冲突主要是出现在多人在修改同一个文件的同一部分内容时，对方当你之前push，然后你后push的时候git检测到两次提交内容不匹配，提示你Conflict，然后你pull下来的代码会在冲突的地方使用=====隔开，此时你需要找到对应的开发人员商量代码的取舍，切不可随意修改并强制提交，解决冲突后再次push即可。
```

## 79.你所知道的前端性能优化方案

```
这个其实方案还是比较多的，可以从DOM层面，CSS样式层面和JS逻辑层面分别入手，大概给出以下几种：
(1) 减少DOM的访问次数，可以将DOM缓存到变量中；
(2) 减少重绘和回流，任何会导致重绘和回流的操作都应减少执行，可将多次操作合并为一次；
(3) 尽量采用事件委托的方式进行事件绑定，避免大量绑定导致内存占用过多；
(4) css层级尽量扁平化，避免过多的层级嵌套，尽量使用特定的选择器来区分；
(5) 动画尽量使用CSS3动画属性来实现，开启GPU硬件加速；
(6) 图片在加载前提前指定宽高或者脱离文档流，可避免加载后的重新计算导致的页面回流；
(7) css文件在<head>标签中引入，js文件在<body>标签中引入，优化关键渲染路径；
(8) 加速或者减少HTTP请求，使用CDN加载静态资源，合理使用浏览器强缓存和协商缓存，小图片可以使用Base64来代替，合理使用浏览器的预取指令prefetch和预加载指令preload；
(9) 压缩混淆代码，删除无用代码，代码拆分来减少文件体积；
(10) 小图片使用雪碧图，图片选择合适的质量、尺寸和格式，避免流量浪费。
```

## 80.get和post有什么区别

其实，GET和POST本质上两者没有任何区别。他们都是HTTP协议中的请求方法。底层实现都是基于TCP/IP协议。所谓区别，只是浏览器厂家根据约定，做得限制而已

```
•	get是通过明文发送数据请求，而post是通过密文；
•	get传输的数据量有限，因为url的长度有限，post则不受限；
•	GET请求的参数只能是ASCII码，所以中文需要URL编码，而POST请求传参没有这个限制
•	GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应	200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）
```

GET和POST两种基本请求方法的区别

```
最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数
```

## 81.JS 各种循环性能对比

新建一个 40000000 个数据测试数组

```
const data = new Array(40000000).fill(0);
```

1.普通 for 循环	平均耗时约：**674.267ms**

```
console.log('-----普通for循环-------');
console.time('for');
const result_1 = [];
for (let i = 0; i < data.length; i++) {
  result_1.push(data[i]);
}
console.timeEnd('for');
console.log('-----执行完毕-------');
```

2.for of	平均耗时约：**1095.000ms**

```
console.log('-----for of-------');
console.time('for_of');
const result_2 = [];
for (let item of data) {
  result_2.push(item);
}
console.timeEnd('for_of');
console.log('-----执行完毕-------');
```

3.for in	平均耗时约：**9213.187ms**

```
console.log('-----for in-------');
console.time('for_in');
const result_3 = [];
for (let key in data) {
  result_3.push(data[key]);
}
console.timeEnd('for_in');
console.log('-----执行完毕-------');
```

4.forEach	平均耗时约：**1022.339ms**

```
console.log('-----forEach-------');
console.time('forEach');
const result_4 = [];
data.forEach((item) => {
  result_4.push(item);
});
console.timeEnd('forEach');
console.log('-----执行完毕-------');
```

5.map	平均耗时约：**6751.867ms**

```
console.log('-----map-------');
console.time('map');
const result_5 = [];
data.map((item) => {
  result_5.push(item);
});
console.timeEnd('map');
console.log('-----执行完毕-------');
```

只看上面的执行结果，性能: **普通 for 循环 > forEach > for of > map > for in**

## 82.vue 	v-if 和 v-show 区别

```
答：简单回复：v-if按照条件是否渲染，v-show是display的block或none；

详细比较：
v-show是css切换，v-if是完整的销毁和重新创建。
使用
频繁切换时用v-show，运行时较少改变时用v-if
v-if=‘false’ v-if是条件渲染，当false的时候不会渲染
```

## 83.vue	$route和$router的区别

```
$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。
```

## 84.vue.js的两个核心是什么？

```
答：数据驱动、组件系统
```

## 85.**vue几种常用的指令**

```
答：v-for 、 v-if 、v-bind、v-on、v-show、v-else
```

## 86.**vue常用的修饰符？**

```
.prevent: 提交事件不再重载页面；
.stop: 阻止单击事件冒泡；
.self: 当事件发生在该元素本身而不是子元素的时候会触发；
.capture: 事件侦听，事件发生的时候会调用
```

## 87.**vue等单页面应用及其优缺点**

```
优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。

缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。
```

## 88.vue	**怎么定义 vue-router 的动态路由? 怎么获取传过来的值**

```
答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。
```

## 89.vue	watch和computed差异

```
watch是进行数据监听，然后进行相应的操作，执行方法等conputed和methods的合体使用，比较耗性能，与vue性能优化相背而驰，尽量减少使用！

computed是数据改变进行相应的数据变化，由老数据迸发新的数据（return返回），会利用缓存机制对 数据进行缓存 ，只有当 依赖数据变化的时候才会进行相应的变化
```

## 90.vue	**组件中data为什么是函数**

```
为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？
因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。
```

## 91.vue	**什么是vue的计算属性？**

```
答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。
好处：
1使得数据处理结构清晰；
2依赖于数据，数据更新，处理结果自动更新；
3计算属性内部this指向vm实例；
4在template调用时，直接写计算属性名即可；
5常用的是getter方法，获取数据，也可以使用set方法改变数据；
6相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。
```

## 92.vue	**对于MVVM的理解？**

```
MVVM 是 Model-View-ViewModel 的缩写。
Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。
View 代表UI 组件，它负责将数据模型转化成UI 展现出来。
ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。
```

## 93.vue	**VUE生命周期的几个阶段**

```
beforeCreate（创建前）
created（创建后）
beforeMount（载入前）
mounted（载入后）
beforeUpdate（更新前）
updated（更新后）
beforeDestroy（销毁前）
destroyed（销毁后）第四拽的
```

## 94.vue	**第一次页面加载会触发哪几个钩子？**

```
答：会触发 下面这几个beforeCreate, created, beforeMount, mounted
```

## 95.vue-router中导航守卫有哪些

##### 全局前置守卫

你可以使用router.beforeEach注册一个全局前置守卫：

![img](file:///C:/Users/华为/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)

当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前一直处于等待中

每个守卫方法接收三个参数：

- to：Route：即将要进入的目标路由对象。

- from：Route：当前导航正要离开的路由。

- next：Function：一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数。

  - - [ ] next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的)。
    - [ ] next(false)：中断当前的导航。如果浏览器的URL改变了(可能是用户手动或浏览器后退按钮)，那么URL地址会重置到from路由对应的地址
    - [ ] next('/')或者next({path: '/'})：跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向next传递任意位置对象，且允许设置诸如replace: true、name: 'home'之类的选项以及任何用在router-link的to prop或router.push中的选项
    - [ ] next(error)：如果传入next的参数是一个Error实例，则导航会被终止且该错误会被传递给router.onError()注册过的回调。
       确保要调用next方法，否则钩子就不会被resolved

##### 全局解析守卫

你可以用router.beforeResolve注册一个全局守卫。这和router.beforeEach类似，区别是在导航被确认之前(跳转路由之前)，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。(beforEach调用之后被调用)

##### 全局后置钩子

你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接收next函数也不会改变导航本身。路由独享的守卫

![img](file:///C:/Users/华为/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)

这些守卫与全局前置守卫的方法参数是一样的。

##### 组件内的守卫

最后，你可以在路由组件内直接定义一下路由导航守卫：

- beforeRouteEnter
- beforeRouteUpdate
- beforeRouteLeave

![img](file:///C:/Users/华为/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

## 96.vue	路由拦截

定义：路由拦截就是路由在发生变化时需要进行的拦截处理，比如跳转到某个页面要判断是否有登录等；

写法：

```
路由拦截   /*在跳转之前执行*/
beforeEach函数有三个参数：
 to:router即将进入的路由对象
 from:当前导航即将离开的路由
 next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。
afterEach函数不用传next()函数
router.beforeEach(function(to, from, next) {
  next()
})
```

主要是对进入页面的限制；比如判断有没有登录，没有就不能进入某些页面，只有登录了之后才有权限查看页面

```
router.beforeEach(function(to, from, next) {
  if (!localStorage.getItem("username")) {  
      if (to.path !== '/login') {
          next('/login')
      }
  };
  next()
})
```

```
/*在跳转之后判断*/
会在每次路由切换成功进入激活阶段时被调用。
Vue.afterEach(function(to,form){
	console.log('成功浏览到: ' + to.path)
})
```

## 97.vue实现数据双向绑定的原理

```
vue实现数据双向绑定主要是：
采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。
```

```
vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。
```

![img](file:///C:/Users/华为/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

## 98.vue 的双向绑定的原理

1. 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
2. 具体实现流程：
   - 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就 通知订阅者
   - 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数， 从而更新视图
   - 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据 初始化模板数据以及初始化相应的订阅器
3. 把下面的流程图说清楚就差不多了：

<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20210301211024048.png" alt="image-20210301211024048" style="zoom:50%;" />

## 99.vue组件间的参数传递

##### **父组件与子组件传值**

```
父组件传给子组件：子组件通过props方法接受数据;
子组件传给父组件：通过事件发送$emit方法传递参数
```

##### **非父子组件间的数据传递，兄弟组件传值**

```
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）
```

## 100.vue的watch的深度使用

深度监听
watch监听属性的变化，当试试对象等复杂类型的时候是无法进行监听的
这个时候要添加deep：true

```
watch: {
   rolesList:{
      handler(old,now){},
      deep:true
   }
}
```

## 101.vue	对keep-alive的理解

**keep-alive**是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。

参数解释:

- include - 字符串或正则表达式，只有名称匹配的组件会被缓存
- exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存
- include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 

![image-20210301212141920](C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20210301212141920.png)

![image-20210301212203636](C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20210301212203636.png)

## 102.浅谈jQuery的链式调用

实现链式的基本条件就是要实例对象先创建好，调用自己的方法。

链式调用是通过return this的形式来实现的。通过对象上的方法最后加上return this，把对象再返回回来，对象就可以继续调用方法，实现链式操作了。

```
Obj().init().setFlag();
```

分解：

```
obj = Obj();
obj.init();
obj.setFlag();
```

如果需要链式的处理，只需要在方法内部返回当前的这个实例对象this就可以了，因为返回当前实例的this，就又可以访问自己的原型了。

```
Obj.prototype = {
	init: function() {
		...
        return this;
    },
	setFlag: function() {
		...
        return this;
    }
}
```

链式调用的好处：节省代码量，代码看起来更优雅。

链式调用的问题：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。

```
	   var MyJQ = function(){}
       
        MyJQ.prototype = {
            css:function(){
               console.log("设置css样式");
                return this;
            },
           show:function(){
                console.log("将元素显示");
               return this;
            },
           hide:function(){
                console.log("将元素隐藏");
           }
       };
        var myjq = new MyJQ();
        myjq.css().css().show().hide();
```

## 103.css不同浏览器兼容性问题的解决方案

**浏览器CSS样式初始化**

由于每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化，相信很多朋友都写过这样的代码，在所有CSS开始前，先把marin和padding都设为0，以防不同浏览器的显示效果不一样

```
*{
    margin: 0;
    padding: 0;
}
```

关于浏览器CSS样式初始化，经验不丰富的话，可能也不知道该初始化什么，这里给大家推荐一个库，Normalize.css，github star数量接近4万，选取展示其中几个样式设置，如下

```
html {
    line-height: 1.15; /* Correct the line height in all browsers */
    -webkit-text-size-adjust: 100%; /* Prevent adjustments of font size after orientation changes in iOS. */
}
 
body {
    margin: 0;
}
 
a {
    background-color: transparent; /* Remove the gray background on active links in IE 10. */
}
 
img {
    border-style: none; /*  Remove the border on images inside links in IE 10. */
}

ul {}
li {}
ol {}
```

## 104.ES6	Set

JS数据结构 Array Object Set Map

Set 类似数组

```
var set = new Set(); //类似数组 成员是唯一的 全等进行匹配
set.add(1);
set.add(2);
set.add(3).add(4).add(5).add('5');
// {1, 2, 3, 4, 5, '5'}
```

Set另一种定义方式

```
var set = new Set([1,2,3,4,5,5]);
console.log(set); //{1, 2, 3, 4, 5}
```

##### 数组去重

```
// es6
var arr = [11,43,11,33];
var s = new Set(arr); //{11, 43, 33}
```

```
// es5
    var arr = [11,43,11,33];
    function f() {
        var array = [];
        for(var i=0; i<arr.length; i++) {
            // if(array.indexOf(arr[i]) == -1) { //没有匹配成功
            //     array.push(arr[i]);
            // }
            if (array.includes(arr[i])) {
                // array.push(arr[i]);
            } else {
                array.push(arr[i]);
            }
        }
        return array;
    }
    f();
```

##### 类型转换

1、 ...[]扩展运算符

```
var arr1 = [...new Set(arr)]; //[11, 43, 33]
```

2、 Array.from()

```
var arr2 = Array.from(new Set(arr)); //[11, 43, 33]
```

##### 遍历方法

```
	const set = new Set([2,3,52,45]);
    set.forEach((v,i) => {
        console.log(v);
    })
    for(let v of set) {
        console.log(v);
    }
```

##### 扩展

求出大于20的数据去重处理

```
var arr = [11,43,11,33,20,45,43];
// 分析思路
// 1、求出大于20
var max = arr.filter(v => v > 20);
// 2、去重
var x = new Set(max);
// 3、类型转换
Array.from(x);
// 4、合并代码
var y = Array.from(new Set(arr.filter(v=>v>20)));
var z = [...new Set(arr.filter(v=>v>20))];
```

并集 数组合并

```
var a1 = [1,2,3,4,5,6,4,5,6];
var a2 = [4,5,6,7,8,9,8,9];
// 1.数组合并
var merge = [...a1,...a2];
// 2.去重
var noDuplicate = new Set(merge);
// 3.类型转换
var a3 = [...noDuplicate];
// 4.合并代码
var a3 = [...new Set([...a1,...a2])];
```

交集 两个相同的

```
// a1中包含a2
var c = a1.filter(v=>a2.includes(v));
var c1 = a1.filter(v=>new Set(a2).has(v));
// 2.去重
var x = new Set(c);
// 3.类型转换
var a3 = [...x];
// 4.合并代码
var a3 = [...new Set(a1.filter(v=>a2.includes(v)))];
var a3 = [...new Set(a1.filter(v=>new Set(a2).has(v)))];
```

差集 两个数组中互相没有的

```
var a3 = [...new Set(a1.filter(v=>!a2.includes(v)))];
var a3 = [...new Set(a1.filter(v=>!new Set(a2).has(v)))];
```

## 105.ES6	Map

Map 类似对象 键值对

```
var m = new Map();
m.set('key', 'value');
m.set('name', 'Ethan').set('age', '12');
var o = { id: 100 };
m.set(o, 'abc');
```

另一种添加方式

```
let m1 = new Map([['a', 1], ['b', 2], ['c', 3], ['id', 4]]);
```

##### Map遍历方法

```
	for (let [k, v] of m1) {
        console.log(k); //a b c id
        console.log(v); //1 2 3 4
    }
```

keys()	values()	entries() -> and脆死

```
	for (let k of m1.keys()) {
        console.log(k);
    }
    for (let v of m1.values()) {
        console.log(v);
    }
```

##### Map类型转换

###### 1.object对象转数组

```
var obj = { 'a': 1, 'b': 2, 'c': 3 };
Object.keys(obj); //["a", "b", "c"]
Object.values(obj); //[1, 2, 3]
```

###### 2.map类型转数组

```
let m1 = new Map([['a', 1], ['b', 2], ['c', 3], ['id', 4]]);
[...m1.keys()]; //["a", "b", "c", "id"]
[...m1.values()]; //[1, 2, 3, 4]
[...m1.entries()];
```

###### 3.map转对象object

```
	let m2 = new Map([['a', 1], ['b', 2], ['c', 3], ['id', 4]]);
    var o2 = {};
    for (let [k, v] of m2) {
        o2[k] = v;
    }
    console.log(o2); // {a: 1, b: 2, c: 3, id: 4}
```

###### 4.对象object转map

```
	var obj = { 'a': 1, 'b': 2, 'c': 3 };
    let m3 = new Map();
    for (let k in obj) {
        m3.set(k, obj[k]);
    }
    console.log(m3);
```

第二种方式

```
let m4 = new Map(Object.entries(obj));
```

## 106.公众号项目中的登录操作

```
1.在路由js中使用路由守卫拦截，判断用户是否登录过有没有token信息，没有就获取token信息，有就next()跳过
2.在http请求头加上token，获取到token后发起微信网页授权，授权完成后跳转至定义重定向的地址进行登录操作
3.项目中封装了axios请求，对每个http请求头都加上token数据的处理
4.http response 拦截器，拦截响应，做统一处理
5.token过期失效409：getUserToKen()重新获取token再次进行微信授权操作
6.token未认证登录401：getUserToKen()重新获取token再次进行微信授权操作
7.每次的路由拦截都会记录to:router即将进入的路由地址，在登录的过程中就会取记录后的地址，跳转到对应的页面
```

## 107.Vue项目中实现用户登录及token验证

```
在前后端完全分离的情况下，Vue项目中实现token验证大致思路如下：

1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码

2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token

3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面

4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面

5、每次调后端接口，都要在请求头中加token

6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401

7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面
```

## 108.CSS 预处理器 sass,less,stylus优缺点

https://www.jianshu.com/p/9d84bb5043bb

##### 基本语法

Less 的基本语法属于「CSS 风格」

Sass、Stylus 相比之下激进一些，利用缩进、空格和换行来减少需要输入的字符

不过区别在于 Sass、Stylus 同时也兼容「CSS 风格」代码

Less & SCSS：

```
.box {
  display: block;
}
```

Sass：

```
.box
  display: block
```

Stylus：

```
.box
  display: block
```

注：后面的 Sass 代码会用被更多人接受的 SCSS 风格给出

##### 嵌套语法

三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 & 也相同。

区别只是 Sass 和 Stylus 可以用没有大括号的方式书写

less

```
.a {
  &.b {
    color: red;
  }
}
```

vue中安装sass，cli2配置---------cli3配置全局sass/scss变量

https://www.jianshu.com/p/ccdae6fb7c2e

https://www.jianshu.com/p/0d3aafbd1cda

## 109.vue-cli 【flexible】屏幕字体自适应布局及配置

很多前端小伙伴在写页面尤其是移动端页面的时候，要求页面布局以及字体大小随屏幕宽度变化而随之按比例自适应*【注：非响应式】*，那么，在vue-cli脚手架中应该如何去实现呢？

##### 1.安装`flexible`库 :

```
//在项目库下运行：
npm i lib-flexible --save-dev 
```

##### 2.项目入口文件`main.js`中引入`lib-flexible`:

```
//main.js中：
import 'lib-flexible'
```

##### 3.在项目`index.html`的`head`中配置`meta`：

```
<meta name="viewport"
            content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
```

##### 4.安装`px2rem-loader`：

```
//在项目库下运行
npm install px2rem-loader --save-dev
```

##### 5.配置`px2rem`编译器：

在`build/utils.js`中，将`px2rem-loader`添加到`cssLoaders`中：

```
//自适应字体配置
const px2remLoader = {
    loader: 'px2rem-loader',
    options: {
        remUnit: 37.5   //设计稿的宽度除以10，现阶段一般设计稿的宽度都为750px。如果基于iPhone5设计则为32.0(320 / 10 = 32)
    }
}

// generate loader string to be used with extract text plugin
  function generateLoaders (loader, loaderOptions) {
    const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]
  /**
  *其余的不用改
  */
  }
```

##### 6.启动项目：

```
npm run dev
```

## 110.vue 移动端适配 amfe-flexible

##### 首先下载：

```
npm install  px2rem-loader --save
npm install amfe-flexible --save
```

##### main.js引入：

```
import Vue from 'vue'
import App from './App'
import router from './router'
import 'amfe-flexible/index.js' // rem h5 适配

Vue.config.productionTip = false

new Vue({
  el: '#app',
  router,
  components: { App },
  template: '<App/>'
})
```

##### build文件夹下的utils.js:

`exports.cssLoaders` 中添加：

```
const px2remLoader = {
    loader: 'px2rem-loader',
    options: {
      remUnit: 75
    }
  }
```

```
const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]
```

## 111.js中普通函数和构造函数的区别

**1、构造函数也是一个普通函数，创建方式和普通函数一样，但\**构造函数习惯上首字母大写\****

**2、构造函数和普通函数的区别在于：调用方式不一样。作用也不一样（\**构造函数用来新建实例对象\**）**

**3、调用方式不一样。**

-  a. 普通函数的调用方式：***\*直接调用\** person();**
-  b.构造函数的调用方式：***\*需要使用new关键字来调用 new Person()\**;**

**4、构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名**

**5、内部用this 来构造属性和方法** 

```
function Person(name,job,age) {
     this.name=name;
     this.job=job;
     this.age=age;
     this.sayHi=function() {
          alert("Hi")
     }
 }
```

**5、构造函数的执行流程**

- A、立刻在堆内存中创建一个新的对象
- B、将新建的对象设置为函数中的this
- C、逐个执行函数中的代码
- D、将新建的对象作为返回值

## 112.小程序登录流程

https://www.jianshu.com/p/4109aa86cb44

微信授权登录流程

1. 第一步：wx.login获取 用户临时登录凭证code

2. 第二步：wx.getUserInfo获取加密过的数据encryptedData和解密参数iv

3. 第三步：把步骤一、二中的code、encryptedData、iv传到开发者自己服务端

   - 第三步：服务端获取到code、encryptedData、iv之后用get方法请求如下微信接口

     ```
     https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code
     
     appid：小程序appid
     
     secret： 小程序密钥
     
     js_code： 第一步获取的临时登录凭证code
     
     grant_type：'authorization_code'
     
     接口会返回 openid, session_key，注意：用户已经授权过的平台还会返回unionId，如果你只是需要unionId，则到此为止
     ```

4. 第四步：仿照示例解密后获得unionId，想做什么就做什么了

   ```
   authLogin () {
     wx.login({
      success: loginRes => {
       let code = loginRes.code // 获取用户临时code
       wx.getUserInfo({
        success: function (res) {
         let encryptedData = res.encryptedData // 获取加密数据
         let iv = res.iv // 解密参数
         // 发送解密必要数据到服务端
         wx.request({
          url: 'http://localhost',
          methods: 'POST',
          data: {
           code: code,
           encryptedData: encryptedData,
           iv: iv
          },
          succeess: res => {
           // 服务端首先调用微信接口获取session_key
           // 用户已经授权过的平台会直接返回unionId
           // 没有授权过则用session_key进行解密
           // 解密成功后服务端根据逻辑返回自定义信息
          }
         })
        }
       })
      }
     })
    }
   ```

新的授权需用button组件调用getUserInfo，所以在这之前无法调用wx.login，但是如果先调用获取用户信息再调用wx.login的话，解密过程会出错，猜测code对应的session_key和之前getUserInfo获取的encryptedData不匹配

在页面的onLoad生命周期里调用wx.login，获取的code存入data以备需要的时候使用，但是code失效时间为5分钟，如果用户停留页面时间过长后点击授权登录，此时的code已经过期了，所以，获取code的函数应该每4分钟左右调用一次

## 113.微信小程序登录流程

https://www.jianshu.com/p/08caac24e74d

##### 登录流程时序

<img src="https://upload-images.jianshu.io/upload_images/4395895-051ab52fee41f534.png?imageMogr2/auto-orient/strip|imageView2/2/w/965/format/webp" alt="img" style="zoom:50%;" />

```
1.由上图可知,首先通过wx.login获取登录code(登录校验码),然后通过wx.request将code发送到开发者服务器,凭借用户的Appid和code从微信服务器获取session_key(本次会话密钥)和openid,在本地服务器根据这两个信息定义用户的登录状态,并且将用户的登录状态返回到界面,这就是一次完整的用户授权过程
2.授权注意点
A.过去老版本的API中可以直接通过wx.authorize({scope: "scope.userInfo"}), 弹出授权界面
腾讯觉得这种授权方式用户体验不好, 现在要求我们自己引导用户授权
B.如何引导用户授权?
添加一个open-type类型为getUserInfo的按钮, 只要用户点击这个按钮就可以弹出授权窗口
<button open-type="getUserInfo" lang="zh_CN" bindgetuserinfo="onGotUserInfo">
获取用户信息
</button>
控件意味着引导用户授权,不会像以前一样莫名其妙的就弹出一个窗口
需要用户授权的原因是使用一些获取用户隐私的API需要用户授权,并不需要刚进入小程序就提示用户授权,这样做用户体验非常差
3.具体授权步骤
在index.wpy中添加上述的授权按钮,并且添加onGotUserInfo(e){console.log(e.detail);}为了保证按钮的美观,可以添加type属性为"primary",然后回到微信开发工具,就会弹出授权窗口,并且会执行onGotUserInfo方法中的内容,打印e.detail:用户获取用户信息返回对象中所有和key有关的内容.
```

##### 微信登录的简单流程

1.通过wx.login()获取登录凭证code
 2.通过button组件的open-type="getUserInfo", 获取用户信息
 3.将获取到的登录凭证和用户信息传递到自己的服务器
 4.在自己的服务器上将登录凭证发送到微信的服务器上换取openid和session_key
 5.利用用户提交的信息在自己的服务器上注册用户账号(等等...)
 6.将注册之后的信息返回给微信小程序
 7.将注册信息保存起来以便以后使用

特殊说明:
0.code: 登录凭证
1.openid: 用户唯一标识 OpenID
2.session_key: 本次登录的会话密钥

## 114.iOS(oc)与vue交互

##### 1、oc调用vue方法

```
  methods:{
      hwajax:function (strings) {
           this.tokenString=strings;
      }
 }
```

需要暴露方法

```
 mounted:function () {
    window.hwajax = this.hwajax;
 }
```

##### 2、oc 调用vue方法

```
methods:{
    onLineCollectionFun:function () {
        var u = navigator.userAgent;
        //android终端
        var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; 
        //ios终端
        var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); 
            if(isAndroid){
                window.android.ocOnLineCollectionFun();
            } else {
                console.log('在线收款')
                window.webkit.messageHandlers.ocOnLineCollectionFun.postMessage({'methodsID':'1'});
            }
    }
}
```

**暴露方法,这步很重要**

```
 mounted:function () {
    window.onLineCollectionFun = this.onLineCollectionFun;
 }
```

vue里调用方法使用:
this.onLineCollectionFun()

## 115.iOS WKWebView JS 与 原生交互

##### JS调用OC

js会通过以下方法调用原生方法

```
window.webkit.messageHandlers.<#对象名#>.postMessage(<#参数#>)
```

在原生中我们只要实现WKScriptMessageHandler的代理方法就行了，值得注意的是参数name需要与上述代码中对象名一致

```
// 添加scriptMessageHandler
- (void)addScriptMessageHandler:(id <WKScriptMessageHandler>)scriptMessageHandler name:(NSString *)name;
```

## 116.信贷管理系统

##### 信贷管理系统实战六：

请求公共处理，组件公共处理，过滤器公共处理，下拉数据公共处理，公共函数定义

过滤器公共处理：

1. 定义单独的过滤器文件夹，其中包含index、filter文件
2. 在main.js中引入过滤器中的index.js
3. filter中定义并返回过滤的方法
4. 引入filter.js，filter返回的是一个大对象
5. 对象的key进行遍历 Object.keys()
6. 循环遍历把对应的值添加到全局的过滤器中，也就是Vue.filter(key,filters[key])
7. 页面中无需再引入过滤器的文件，可直接调用里面的方法

```
import Vue from 'vue'
import * as filters from './filters'  //相当于取出所有，别名   filters是一个对象

Object.keys(filters).forEach(key=>{
    console.log(key);
    console.log(filters[key]);
    Vue.filter(key,filters[key])
})
```

##### 信贷管理系统实战七：

```
权限管理-比如说登录后再进行退出操作，浏览器返回上一页就会造成不用登录直接进入页面了
所以在路由拦截中对角色进行了判断处理，取不到角色的将会重新去登录再取得角色信息
```

##### 信贷管理系统实战八：

###### 动态路由处理：

在路由加载时会根据角色的不同对路由进行动态处理router.addRoutes([])

1. 在路由中添加角色标签，角色的值根据后端返回的结果

2. 路由js中将路由数据分为两个数组，常规配置，动态配置，已进入默认添加常规配置

3. 在路由拦截中进行处理

   - 获取角色

     ```
     var {roles} = await store.dispatch('userinfo');
     ```

   - 取出角色

     ```
     var rolesName = roles.map(v => v.name);
     ```

   - 过滤角色 （过滤后的角色信息）

     ```
     var filterRoutes = await store.dispatch('vuex权限处理',rolesName);
     
     permission.js
     相当于是计算属性，对路由进行过滤，判断，什么展示什么不展示
     获取到路由中的两组数据，判断角色中是否包含对应的角色，进行push操作
     ```

   - 动态加载

     ```
     router.addRoutes(filterRoutes);
     ```

## 117.什么是原型?

##### 原型链：

简单来讲就是原型组成的链，比如函数的原型是Function，Function的原型是Object，Object的原型仍然是Object，一直追溯到最终的原型对象。

函数通过prototype来追溯原型对象，对象通过_proto_来追溯原型对象。

通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。

在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。

##### 原型链继承：

```
function A(){
    this.name="amy";
}
function B(){
    this.age="20"; //B继承了A,通过原型，形成链条
}
B.prototype=new A();
var a=new B();
console.log(a.name)//结果：amy
```

## 118.什么是闭包？

```
闭包就是能够读取其他函数内部变量的函数，通常是函数嵌套时产生，它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在外部函数调用后被自动清除。
```

## 119.如何防抖？

##### **何为防抖** 

多次触发事件后，事件处理函数只执行一次，并且是在触发操作结束时执行，一般用于scroll事件。

##### **解决原理** 

对处理函数进行延时操作，若设定的延时到来之前再次触发事件，则清除上一次的延时操作定时器，重新定时

```
let timer;
window.onscroll  = function () {
    if(timer){
        clearTimeout(timer)
    }
    timer = setTimeout(function () {
        //滚动条位置
        let scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        console.log('滚动条位置：' + scrollTop);
        timer = undefined;
    },200)
}
```

## 120.什么是跨域？

```
跨域需要针对浏览器的同源策略来理解，同源策略指的是请求必须是同一个端口，同一个协议，同一个域名，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。

受浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。
```

## 121.如何阻止默认事件？

w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false，比如：

```
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
}
return false也能阻止默认行为。
```

## 122.如何阻止冒泡？

```
w3c的方法是e.stopPropagation()
IE则是使用e.cancelBubble = true。
例如： window.event? window.event.cancelBubble = true : e.stopPropagation();
```

## 123.什么是事件冒泡？什么是事件捕获？

```
冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。

捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。

支持W3C标准的浏览器在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行。而不兼容W3C的浏览器(IE)用attachEvent()方法，此方法没有相关设置，不过IE的事件模型默认是在事件冒泡时执行的，也就是在useCapture等于false的时候执行，所以把在处理事件时把useCapture设置为false是比较安全，也实现兼容浏览器的效果。
```

## 124.什么是事件代理/事件委托？

```
事件代理/事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。
```

## 125.原型

##### 定义

用原型实例指向创建对象的类，使用于创建新的对象的类的共享原型的属性与方法

原型是一个对象，其它对象可以通过它实现属性继承

##### JS对象分两种

普通对象object和函数对象function

```
prototype是函数才有的属性
__proto__是每个对象都有的属性 
```

##### 普通对象和函数对象区别

凡是通过new Function创建的对象都是函数对象，其他都是普通对象（通常通过Object创建），可以通过typeof来判断。

```
function f1(){};
typeof f1 //"function"

var o1 = new f1();  //函数实例
typeof o1 //"object"

var o2 = {};
typeof o2 //"object"
```

```
1、每一个函数对象都有一个prototype属性，但是普通对象是没有的；
　 prototype下面又有个construetor，指向这个函数。
2、每个对象都有一个名为__proto__的内部属性，指向它所对应的构造函数的原型对象，原型链基于__proto__;
```

##### 原型的写法

```
function Person(){};  //定义一个函数对象
Person.prototype.name="abc";  //原型对象中添加属性
Person.prototype.age = 18;
var p1 = new Person();  //实例化
var p2 = new Person();
```

##### 原型分解图

<img src="file://D:\CodeLive\project\practice-project\金渡前端VIP课程项目练习\课堂笔记资料\img\原型.png?lastModify=1615137023" alt="原型" style="zoom:80%;" />

![原型1](file://D:\CodeLive\project\practice-project\金渡前端VIP课程项目练习\课堂笔记资料\img\原型1.png?lastModify=1615137043)

##### 为什么使用function中的prototype? 为什么要继承

需求：生成多个实例

```
var cat1 = {};//创建一个空对象
cat1.name="大明";
cat1.color ="黄色";
var cat2 = {};//创建一个空对象
cat2.name="小明";
cat2.color ="白色";
//缺点，如果有几十个实例，写起来麻烦，且实例与原型没有关联
```

封装一个函数

```
function cat(name,color){   
    return {
        name:name,
        color:color
	}
};
var cat1 = cat("大明","黄色"); 
var cat2 = cat("小明","白色");
```

构造函数

```
function Cat(name,color){   //构造函数
	this.name = name;
	this.color = color;
};
var cat1 = new Cat("大明","黄色");
var cat2 = new Cat("小明","白色");
```

如果当前cat函数中添加了eat()方法和type属性

```
function Cat(name,color){  
	this.name = name;
	this.color = color;
	this.type='动物';
	this.eat = function(){console.log("吃老鼠")};
};
存在一个浪费内存的问题，那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容
既不环保，也缺乏效率
```

解决方法：

```
function Cat(name,color){   //构造函数
	this.name = name;
	this.color = color;
	//this.type='动物';
	//this.eat = function(){console.log("吃老鼠")};
};
Cat.prototype.type='动物';
Cat.prototype.eat = function(){console.log("吃老鼠")};
```

##### 验证

```
console.log('name' in p1);  //in  不管自身的还是原型 都返回true
console.log('type' in p1);
console.log(p1.hasOwnProperty('name'));  //hasOwnProperty() 自身返回true  原型 返回false
console.log(p1.hasOwnProperty('type'));
```

##### 继承

###### 原型继承

```
function Animal(){
	this.type = "动物"
};

function Cat(name,color){
	this.name = name;
	this.color = color;
};
Cat.prototype = new Animal();
var c1 = new Cat('x','白色');
var c2 = new Cat('t','花色');
c1.type
优点：同一个原型对象
缺点：不能修改原型对象，会影响所有实例
```

```
function Animal(){   //动物对象   
	this.type = '动物'
};
function Cat(name,color){   //猫对象  
	this.name = name;
	this.color = color;
	this.type='我是猫';
};
Cat.prototype = new Animal();  //猫的原型对象指向了动物函数
var cat1 = new Cat("大明","黄色");
var cat2 = new Cat("大明","黄色");
console.log(cat1.type); //获取的是当前构造器中的属性
console.log(cat2.type); //获取的是当前构造器中的属性
//想获取Animal成员值
console.log(cat1.__proto__.type);
console.log(cat2.__proto__.type);
//当我们访问一个原型对象的属性时，__proto__是一级级来获取，当继承关系很复杂，未知继承时
```

###### 构造函数的继承

```
function Animal(){  
    this.type = "动物"
};
function Cat(name,color){       
    Animal.apply(this);   //将Animal对象的成员放到Cat对象上
    this.name = name;
    this.color = color;
};
var cat1 = new Cat("大明","黄色"); 
var cat2 = new Cat("小明","白色");
cat1.type = '我是黄猫';
cat2.__proto__.type = '我是动物';
console.log(cat1.type); //'我是黄猫'  cat1被修改
console.log(cat2.type); //"动物"
优点：不存在修改原型对象影响所有实例，各自拥有独立属性
缺点：父类的成员会被创建多次，存在冗余且不是同一个原型对象
通过apply/call只能拷贝成员，原型对象不会拷贝
```

###### 组合继承

```
 function Animal(){   
 	this.type = '动物'
 };
Animal.prototype.eat = function(){console.log('吃')};  
function Cat(name,color){  
	this.name = name;
	this.color = color;
	Animal.call(this); 
};
Cat.prototype = new Animal();  
var cat1 = new Cat("大明","黄色");
var cat2 = new Cat("小明","白色");
cat1.type = '我是黄猫';  //修改当前构造器中的属性
cat2.__proto__.type = '我是动物';//修改了原型对象的值，但并不影响cat1,cat2的值
console.log(cat1.type); //'我是黄猫'  //原型对象的值变化，并不影响构造函数值
console.log(cat2.type); //'动物'
console.log(cat2.__proto__.type);  //'我是动物
cat1.eat(); //还可以调用原型对象中eat()方法
```

##### 原型链

```
function F1(){
	this.name1 = 'f1'
};
F1.prototype.name = 'object';
function F2(){
	this.name2= 'f2'
};
function F3(){
	this.name3 = 'f3'
};
F2.prototype = new F1();  //f2的原型是f1
F3.prototype = new F2();  //f3的原型是f2
var f = new F3();   //实例化的处理
f.name1;
f.__proto__.__proto__.__proto__.name= '12414';
//修改
//f.__proto__.__proto__.__proto__.name= '12414';
//删除
delete f.__proto__.__proto__.__proto__.name;
```

## 126.Vue 3  响应式优化

为什么要用 Proxy API 替代 defineProperty API？

1. defineProperty 的局限性的最大原因是它只能针对单例属性做监听，Vue2.x中对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。
2. 在Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 setter 监听的，这是 defineProperty 的局限性。
3. Proxy 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。
4. Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

## 127.vue 的双向绑定原理

1. 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
2. 具体实现流程：
   - 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就
     通知订阅者
   - 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，
     从而更新视图
   - 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据
     初始化模板数据以及初始化相应的订阅器
3. 把下面的流程图说清楚就差不多了：

## 128.整理对原型链的理解

prototype是函数才有的属性

__proto__是每个对象都有的属性

1. 每一个函数对象都有一个prototype属性，但是普通对象是没有的；prototype下面又有个construetor，指向这个函数
2. 每个对象都有一个名为__proto__的内部属性，指向它所对应的构造函数的原型对象，原型链基于__proto__，对象可以通过 __proto__ 自下而上来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链
3. 简单来讲就是原型组成的链，比如函数的原型是Function，Function的原型是Object，Object的原型仍然是Object，一直追溯到最终的原型对象
4. 函数通过prototype来追溯原型对象，对象通过*proto*来追溯原型对象。

## 129.前端从哪些方面做性能优化？(加载层面)

1. 减少http请求(精灵图，雪碧图，CSS、js文件的合并，用CSS代替图片)
2. 缩减文件大小(资源压缩，webpack，GZip压缩，图片压缩)
3. CDN ( 大图加载，大文件，类库)
4. http2
5. SSR服务端渲染(vue)，预渲染...
6. 懒加载，减少首屏加载量
7. 减少回流，使用定位等，对于操作量比较大的dom，用文档碎片去做（虚拟dom原理）
8. 缓存（cache）

## 130.公众号项目中的锚点定位

$el:所绑定的元素，可以用来直接操作 DOM

offsetTop：元素到offsetParent顶部的距离

offsetParent：距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent为body

```
    tabChanges1(val) {
      let target = document.querySelector("body");
      if (val == 0) {
            var anchor = this.$el.querySelector("#article");
          } else if (val == 1) {
        var anchor = this.$el.querySelector("#aaa");
      } else if (val == 2) {
        var anchor = this.$el.querySelector("#costExplain");
      } else if (val == 3) {
        var anchor = this.$el.querySelector("#notice");
      }
      console.log(anchor.offsetTop, anchor.scrollHeight, anchor.clientHeight);
      let srcollHeight =
        document.documentElement.scrollTop ||
        window.pageYOffset ||
        document.body.scrollTop;
      if (document.documentElement || document.body) {
        // srcollHeight = anchor.offsetTop;
        $("html,body").scrollTop(anchor.offsetTop); // 兼容性更好 ios/Android
        // $(window).scrollTop(anchor.offsetTop);
      }
    }
```

## 131.公众号项目中的微信支付

1.调取后端的支付接口，获取所需的微信参数数据

2.微信内H5调起支付 WeixinJSBridge(不瑞去)，传入对应的参数微信签名、随机串、公众号名称等就可弹出支付窗口

```
				// 微信内H5调起支付
                    WeixinJSBridge.invoke(
                      "getBrandWCPayRequest",
                      {
                        appId: params.appId, //公众号名称，由商户传入
                        timeStamp: params.timeStamp, //时间戳，自1970年以来的秒数
                        nonceStr: params.nonceStr, //随机串
                        package: params.package,
                        signType: params.signType, //微信签名方式：
                        paySign: params.paySign //微信签名
                      },
                      function(res) {
                        if (res.err_msg == "get_brand_wcpay_request:ok") {
                          // 使用以上方式判断前端返回,微信团队郑重提示：
                          //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。
                          this.$router.push("/shopOrder/" + 0);
                        } else {
                          Toast("取消支付");
                        }
                      }
                    );
```

## 132.TS的理解

##### TypeScript 的优势

typeScript支持es6规范

强大的IDE支持：体现在三个特性上

```
1.类型检查，在TS中允许你为变量指定类型。
2.语法提示。
3.方便重构。
```

TypeScript 增加了静态类型、类、模块、接口和类型注解

TypeScript 可用于开发大型的应用、Angular2、vue3的开发语言

------



##### JavaScript 与 TypeScript 的区别

TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。

TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。

##### TypeScript 的缺点

有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端开发可能不是很熟悉的知识点

## 133.js滚动到底加载下一页

1.获取滚轮位置

```
var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
this.height1 = scrollTop;
```

2.文档高度

```
this.height2 = document.body.scrollHeight;
```

3.可视区域

client(快嗯特)

```
this.height3 = document.compatMode == "CSS1Compat" ? document.documentElement.clientHeight : document.body.clientHeight;
```

available条件是为了防止触底时一直不断地请求。因此，请求一次后available设为0，直到滚动到离底部超过100距离（即数据加载玩后）才设为1

```
						//可视区域+滚动条位置>文档高度-加载下一页
						if (this.height3 + this.height1 >= this.height2 - 100 && this.available) {
					       //请求下一页
					       this.page++;
					       this.available = 0;
						   this.loadList();
						//可视区域+滚动条位置<文档高度-不加载
					    } else if (this.height3 + this.height1 < this.height2 - 100) {
					       this.available = 1;
					    }
```

## 134.for循环中key的作用

```
四个字: 性能优化
简述: 让vue在更新数据的时候可以更有针对性的(diff时更快更准确找到变化的位置)
如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法,由于我们在之前没有绑定key,vue在渲染的时候会尽可能少的更新减少动态元素的创建,就是复选框并没有重新创建渲染,只是在复用复选框
```

通过v-model实现组件间的数据绑定

## 兄弟组件传参

场景：testA.vue和testB.vue二个子组件，testA.vue获取到testB.vue的值

```
index.vue
<div>
  <h1>父组件：{{title}}</h1>
  <testA :title="title"/>
  <testB @e-child="acceptSon"/>
</div>
methods:{
    acceptSon(res){  //接受testB子组件信息，同时传给testA
       this.title = res
    }
}

testA.vue
A组件：<button>{{title}}</button>
props:{
    title:String
}

testB.vue
B组件：<input type="text" v-model="title" @input="send()" />
data(){
    return{
      title:'testB',
      
    }
},
methods:{
    send(){
        this.$emit('e-child',this.title)    //发射一个事件   把子的值传给父 
    }
}
```

vue混入

## vue中如何让子组件修改父组件数据

##### **一、关于vue中watch的认识**

我们要监听一个属性的的变化就使用watch一般是父组件传递给子组件的时候

**1、常见的使用场景**

```
watch:{
  value(val) {
    console.log(val);
    this.visible = val;
  }
}
```

**2、如果要一开始就执行**

```
watch: {
  firstName: {
    handler(newName, oldName) {
      this.fullName = newName + '-' + this.lastName;
    },
    immediate: true,
  }
}
```

**3、深度监听(数组、对象)**

```
watch: {
  obj: {
    handler(newName, oldName) {
    console.log('///')
  },
  immediate: true,
  deep: true,
}
```

##### **二、关于子组件修改父组件属性认识**

**1、通过事件发送给父组件来修改**

```
**在子组件test1中**
<input type="text" v-model="book"/>
<button @click="add">添加</button>
<p v-for="(item, index) of books" :key="index">{{item}}</p>
...
methods: {
  add() {
    // 直接把数据发送给父组件
    this.$emit('update', this.book);
    this.book = '';
  },
},
**在父组件中**
<test1 :books="books" @update="addBook"></test1>
...
addBook(val) {
  this.books = new Array(val)
},
```

**2、使用.sync 来让子组件修改父组件的值(其实是上面方法的精简版)**

```
**在父组件中,直接在需要传递的属性后面加上.sync**
<test4 :word.sync="word"/>
**在子组件中**
<template>
  <div>
    <h3>{{word}}</h3>
    <input type="text" v-model="str" />
  </div>
</template>
<script>
export default {
  props: {
    word: {
      type: String,
      default: '',
    },
  },
  data() {
    return {
      str: '',
    }
  },
  watch: {
    str(newVal, oldVal) {
      // 在监听你使用update事件来更新word,而在父组件不需要调用该函数
      this.$emit('update:word', newVal);
    }
  }
}
</script>
```

## Vue 父组件如何监听子组件的生命周期

##### 一、通过 $emit 实现

这里以 mounted 为例，在父组件 Parent 和子组件 Child 中，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：

```
// 父组件 Parent.vue中
<Child @mounted="doSomething"/>
    
// 子组件 Child.vue中
mounted() {
  this.$emit("mounted");
}
```

以上方法虽然可行，但每次都需要手动写一次 $emit 触发父组件的事件。

更简单的方式可以在父组件引用子组件时通过 @hook 来监听生命周期。

##### 二、通过 @hook 实现

还是父组件 Parent 和子组件 Child，@hook 的写法如下：

```
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},

//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    

// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...  
```

当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等生命周期都可以监听。

## vue父组件如何调用子组件里面的方法

在vue里，父组件要调用子组件里边定义的方法，可以通过ref属性来获取到子组件的方法并执行，下面直接贴上子组件和父组件的代码吧！

代码解析：

1、最重要的部分是在父组件调用子组件的标签上，定义了一个ref属性：child，通过这个属性，可以获取到子组件里面的的属性和方法。

2、在父组件的方法 parentMethod 执行的时候，使用：this.$refs.child.childMethod(); 来调用子组件的方法。

父组件代码：

```
<template>
  <div class="parent">
    <div class="parent-wrapper">
      <button @click="parentMethod">我是父组件的按钮，但是我可以调用子组件的方法</button>
    </div>
    <Child ref="child"></Child>
  </div>
</template>
 
<script>
import Child from '@/components/test/Child'
export default {
  name: 'parent',
  data () {
    return {
      
    }
  },
  components: {
    Child
  },
  methods: {
    parentMethod(){
      this.$refs.child.childMethod();
    }
  }
}
```

子组件代码：

```
<template>
  <div class="child">
    <div class="child-wrapper">
      <button @click="childMethod">这是子组件的按钮</button>
    </div>
  </div>
</template>
 
<script>
export default {
  name: 'child',
  data () {
    return {
      
    }
  },
  methods: {
    childMethod() {
      alert("我是子组件的方法！")
    }
  }
}
</script>
```

## ajax和axios的区别以及axios原理

##### jquery ajax

它是对原生XHR的封装，随着vue、react框架的兴起，很多情况下我们只需使用ajax可是却要引入整个jquery，这是非常不合理。

```
$.ajax({
     type:'POST',
     url:url,
     data:data,
     dataType:dataType,
     success:function(){},
     error:funciton(){}
})
```

优点：响应快，使用方便。
缺点：

- 针对MVC的编程设计，不符合现在的MVVM趋势
- 基于原生的XHR开发。
- JQuery较大，单纯的使用ajax要引入这个文件不合理。

##### Axios

Vue2.0之后，Axios受到了更多人的关注。Axios本质是对原生XHR封装,需要一个promise对返回的结果进行处理。

- 支持Promise API
- 将返回的数据自动转化成JSON数据====transformResponse
- 可以取消请求====request.abort()
- 提供一些并发请求的接口。

```
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // Both requests are now complete
  }));
```

- 防止CSRF攻击：每次请求都要带一个从cookie中获取的key值，根据同源策略，假冒的网站拿不到cookie中的key，后台可以根据这个请求判断是不是有人假冒，从而采取正确的策略。

  ```
  axios({
    methods:'post',
    url:url,
    data:data
  
  }).then((resopnse)=>{
    console.log(response)
  }).catch((error)=>{
     console.log(error)
  })
  ```

##### Axios的原理解读

```
底层还是对`XHR`的封装，只不过需要一个`Promise`对象对返回的结果进行处理。`axios`在浏览器端是和Ajax底层的原理一样，都是通过`XMLHttpRequest`对象进行的一次封装。
```

## http请求的流程

一个完整的http请求过程可分为以下几个部分：

浏览器发起请求-> 解析域名得到ip进行TCP连接 ->浏览器发送HTTP请求和头信息发送->服务器对浏览器进行应答，响应头信息和浏览器所需的内容-> 关闭TCP连接或保持-> 浏览器得到数据数据进行操作。

http请求过程有：

1. 建立TCP连接

2. Web浏览器向Web服务器发送请求命令

3. Web服务器应答

4. Web服务器关闭TCP连接

5. 浏览器接受到服务器响应的数据

   ![img](https://img.php.cn/upload/article/000/000/028/5caecfcae0102771.jpg)

## 项目中如何打包不同环境

https://www.jianshu.com/p/320d9efccc6a

https://blog.csdn.net/weixin_44092113/article/details/85074709

## Vue如何实现数据劫持

##### **Object.defineProperty**

在vue2.x版本中，数据劫持是用过Object.defineProperty这个API来实现

```
var message = 'hello world';
const data = {};
Object.defineProperty(data, 'message', {
    get() {
        return message;
    },
    set(newVal) {
        message = newVal;
    }
});
data.message // 'hello world'
data.message = 'test' // 'test'
```

第一个参数是要定义属性的对象，第二个参数是要定义属性的名称，第三个参数是被定义的属性描述符

当我们读取或者设置被定义的属性时，就会执行get或者set方法，也就是在这两个方法中，我们实现数据劫持，可以在这里添加一些我们附加的操作，而不只是简单的读写。

那么在vue中，是怎么实现对data中所有的属性做到数据劫持的呢？其实原理都一样，我们只需遍历所有data对象中的所有属性，并对每一个属性使用**Object.defineProperty劫持**即可，当属性的值发生变化的时候，我们执行一系列的渲染视图的操作。下面我们看一个简单的vue数据劫持的实现。

## Vuex与全局变量的区别

```
1.响应式：vuex的状态存储是响应式的，当vue组件从store中读取状态的时候，若store中的状态发生变化那么相应的组件也会得到高效更新
2.不能直接改变store：不能直接改变store的变化，改变store中状态的唯一途径是commit mutation 方便与跟踪每一个状态的变化
```

## Vuex在项目中什么时候需要用到

```
当应用遇到多个组件共享状态的时候，即：多个视图依赖于同一个状态，不同视图的行为需要变更同一状态
对于页面之间的传参对于多层嵌套组件将会很繁琐，对于兄弟组件之间的状态传递无能为力，所以就将这些的共享状态抽取出来，以全局单例模式管理，即vuex
```

## Vuex的优点

```
vuex是状态管理机制，是为了解决垮组件之间数据共享问题的，一个组件的数据变化会映射到使用这个数据的其他组件当中，如果刷新页面之前存储的vuex数据全部都会被初始化
模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理
```

## Vuex刷新页面数据丢失怎么解决

```
1.问题描述：一般登录成功的时候需要把用户信息，菜单信息放置在vuex中，作为全局的共享数据。但是在页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。因为vuex里的数据时保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里的数据就会被重新赋值。

2、解决思路：
办法一：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）
办法二：在页面刷新的时候再次请求远程数据，使之动态更新vuex数据
办法三：在父页面向后台请求远程数据，并且在页面刷新前将vuex的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）
分析：
办法一的缺点是不安全，不适用大数据量的存储；
办法二适用于少量的数据，并且不会出现网络延迟；
办法三是办法二和办法一配合使用。

3、解决过程：
3.1、选择合适的浏览器存储
localStorage  --  是永久存储在本地，除非你主动去删除;
sessionStorage  --  是存储到当前页面关闭为止，和其他tab页没关联;
cookie  --  则根据你设置的有效时间来存储，但缺点是不能储存大数据且不易读取，会和后台进行交互。

本方法选择的是sessionStorage，选择的原因是由于vue是单页面应用，操作都是在一个页面跳转路由，另一个原因是sessionStorage可以保证打开页面时sessionStorage的数据为空，而如果是localStorage则会读取上一次打开页面的数据。

3.2、解决方案
由于state里的数据是响应式，所以sessionStorage存储也要跟随变化，而且只能通过mutations来改变state中的值。首先在用户登录成功之后，然后把用户信息，菜单信息通过actions分发保存至vuex中。然后在菜单页面计算vuex中state的菜单数据，将数据解析组装成前端组件所需的格式，然后渲染组件，生成菜单树。如果页面没有刷新，则一切正常。

登录成功后将用户和菜单数据同步至vuex
```

<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20210905160809200.png" alt="image-20210905160809200" style="zoom: 33%;" />

在菜单页面监听vuex中菜单数据

<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20210905160933279.png" alt="image-20210905160933279" style="zoom:50%;" />

页面刷新的解决方案：

页面刷新的时候异步请求后台数据，然后动态更新vuex中的数据，其中会有一种情况就是，网络延迟、数据量大的问题。此时还没等vuex获取到后台返回的数据，页面就已经加载完成了，这样就会造成数据丢失。所以该解决方案就是，监听浏览器刷新前事件，在浏览器刷新之前就把vuex里的数据保存至sessionStorage中，刷新成功后如果异步请求的数据还没返回则直接获取sessionStorage里的数据，否则获取vuex里的数据。（只有刷新后还没取到后台数据，才会从sessionStorage里取。确保数据的安全性，就算获取sessionStorage里的数据也是安全的，因为每次刷新都会重新赋值，不必担心数据被篡改问题，其次就是对sessionStorage里的数据做了加密操作）

在父页面向后台请求数据，并且监听浏览器刷新前事件，将vuex数据保存至sessionStorage

在父页面向后台请求数据，将返回的数据分发至vuex

<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20210905161030914.png" alt="image-20210905161030914" style="zoom: 33%;" />

## Vuex的流程

```
页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation，mutation会修改state中对应的值。最后通过getter把对应值跑出去，在页面的计算属性中，通过，mapGetter来动态获取state中的值
```

## Vuex有哪几种属性

```
有五种,分别是State , Getter , Mutation , Action , Module (就是mapAction)

1. state：vuex的基本数据，用来存储变量

2. geeter：从基本数据(state)派生的数据，相当于state的计算属性

3. mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。

4. action：和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。

5. modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。
```

## rem和em区别

在css中单位长度用的最多的是px、em、rem，这三个的区别是：
px是固定的像素，一旦设置了就无法因为适应页面大小而改变。
em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。
对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。
rem中的r意思是root（根源），这也就不难理解了。

```
em：
子元素字体大小的em是相对于父元素字体大小
元素的width/height/padding/margin用em的话是相对于该元素的font-size
<div>
    我是父元素div
    <p>
        我是子元素p
        <span>我是孙元素span</span>
    </p>
</div>

div {
  font-size: 40px;
  width: 10em; /* 400px */
  height: 10em;
  border: solid 1px black;
}
p {
  font-size: 0.5em; /* 20px */ 
  width: 10em; /* 200px */
  height: 10em;
  border: solid 1px red;
}
span {
  font-size: 0.5em;  
  width: 10em;
  height: 10em;
  border: solid 1px blue;
  display: block;
}
```

<img src="https://images2015.cnblogs.com/blog/998023/201706/998023-20170610102033528-2136899548.png" alt="img" style="zoom: 80%;" />

```
rem：
rem是全部的长度都相对于根元素，根元素是谁？<html>元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。
上代码：（html代码如上，只是把css代码的元素长度单位变了）
html {
    font-size: 10px;
    }
div {
    font-size: 4rem; /* 40px */
    width: 30rem;  /* 300px */
    height: 30rem;
    border: solid 1px black;
}
p {
    font-size: 2rem; /* 20px */
    width: 15rem;
    height: 15rem;
    border: solid 1px red;
}
span {
    font-size: 1.5rem;
    width: 10rem;
    height: 10rem;
    border: solid 1px blue;
    display: block;
} 
```

![img](https://images2015.cnblogs.com/blog/998023/201706/998023-20170610103617278-75811825.png)

**总结**：

在做项目的时候用什么单位长度取决于你的需求，我一般是这样的：

像素（px）：用于元素的边框或定位。

em/rem：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰。

## 浏览器渲染原理与过程

要了解浏览器渲染页面的过程，首先得知道一个名词——关键路径渲染。**关键渲染路径**（Critical Rendering Path）是指与当前用户操作有关的内容。例如用户在浏览器中打开一个页面，其中页面所显示的东西就是当前用户操作相关的内容，也就是浏览器从服务器那收到的HTML,CSS,JavaScript等相关资源，然后经过一系列处理后渲染出来的web页面。

```
而浏览器渲染的过程主要包括以下五步：

1.浏览器将获取的HTML文档并解析成DOM树。

2.处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。

3.将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象。

4.渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素。

5.将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting.

浏览器获取HTML文档并解析成DOM树
处理CSS解析构成层叠样式表模型CSSOM(CSS Object Model)
将DOM和CSSOM合并为渲染树
浏览器使用一种流式处理的方法，进行渲染树布局
最后渲染树绘制的各个节点绘制到屏幕上
```

## 浏览器渲染网页的具体流程

```
2.1 构建DOM树
当浏览器客户端从服务器那接受到HTML文档后，就会遍历文档节点然后生成DOM树，DOM树结构和HTML标签一一对应。需要注意记下几点：

DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。（这在后面会详细介绍。）

display:none 的元素也会在DOM树中。

注释也会在DOM树中

script标签会在DOM树中

2.2 CSS解析
浏览器会解析CSS文件并生成CSS规则树，在过程中，每个CSS文件都会被分析成StyleSheet对象，每个对象都包括CSS规则，CSS规则对象包括对应的选择器和声明对象以及其他对象。
在这个过程需要注意的是：

CSS解析可以与DOM解析同进行。

CSS解析与script的执行互斥 。

在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥。

2.3 构建渲染树（Rendr tree construction）
通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，让后对每个可见节点找到适配的CSS样式规则并应用。具体的规则有以下几点需要注意：

Render Tree和DOM Tree不完全对应。

display: none的元素不在Render Tree中

visibility: hidden的元素在Render Tree中

2.4 渲染树布局(layout of the render tree)
布局阶段会从渲染树的更节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：

float元素，absoulte元素，fixed元素会发生位置偏移。

我们常说的脱离文档流，其实就是脱离Render Tree。

2.5 渲染树绘制（Painting the render tree）
在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。
```

## axios封装

```
import axios from "axios";
import Vue from '../main';

function getTokenByLocal() {
    let token = sessionStorage.getItem('token')
    return token
}

// axios实例
const service = axios.create({
    baseURL: '/sys',
    timeout: 5000
})

// 请求拦截
service.interceptors.request.use(
    config => {
        if(getTokenByLocal()) {
            // 为所有接口都设置token
            config.headers['token'] = getTokenByLocal()
        } else {
            // 返回登录页
            Vue.$router.push('/login')
        }
        return config
    },
    error => {
        return Promise.reject(error)
    }
)

// 响应拦截
service.interceptors.response.use(
    response => {
        let res = response.data
        // 200 400 500
        if(res.code == '200') {

        }
        // 未登录
        if(res.code == '-101') {
            Vue.$router.push('/login')
        }
        return Promise.resolve(res)
    },
    error => {
        return Promise.reject(error)
    }
)

export default service
```

## 跨域方案

相关代码请参考 github.com/mcuking/blo…

- JSONP
- CORS
- postmessage
- nginx反向代理接口跨域
- document.domain + iframe
- window.name + iframe
- location.hash + iframe

## 一次完整的HTTP事务流程

（1）域名解析

（2）发起TCP的三次握手

（3）建立TCP连接后发起http请求

（4）服务器响应http请求，浏览器得到HTML代码

（5）浏览器解析HTML代码，并请求HTML代码中的资源

（6）浏览器对页面进行渲染呈现给用户

（7）连接结束

## 从输入URL到渲染出整个页面的过程包括三个部分：

1、DNS解析URL的过程

2、浏览器发送请求与服务器交互的过程

3、浏览器对接收到的html页面渲染的过程

#### **一、DNS解析URL的过程**

   DNS解析的过程就是寻找哪个服务器上有请求的资源。因为ip地址不容易记忆，一般会使用URL域名（如www.baidu.com）作为网址。DNS解析就是将域名翻译成IP地址的过程。

具体过程：

​    1）浏览器缓存：浏览器会按照一定的频率 缓存DNS记录

 　2）操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会取操作系统中找

　　 3）路由缓存：路由器也有DNS缓存

　　 4）ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求

　　 5）根服务器：ISP的DNS服务器找不到之后，就要向根服务器发出请求，进行递归查询

#### **二、浏览器与服务器交互过程**

　　1）首先浏览器利用tcp协议通过三次握手与服务器建立连接

　　http请求包括header和body。header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie。body中有请求的内容。

　　2）浏览器根据解析到的IP地址和端口号发起http的get请求.

　　3）服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

　　4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染

#### **三、浏览器页面渲染过程**

　　1）浏览器根据深度遍历的方式把html节点遍历成dom 树

　　2）将css解析成CSS DOM树

　　3）将dom树和CSS DOM树构造成render树

　　4）JS根据得到的render树 计算所有节点在屏幕中的位置，进行布局（回流）

　　5）遍历render树并调用硬件API绘制所有节点（重绘）

## http与https区别

```
1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)

2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)
```

## 项目中与原生的交互

```
/**
 * 向安卓 / ios 传值
 * @param {JSON} value 传的值
 * @param {string} name 方法名
 */
export const postAppPrams = (name, value = {}) => {
  const paramsValue = JSON.stringify(value) || ''

  if (deviceType() === 2) {
    // ios
    if (
      window['webkit'] &&
      window['webkit']['messageHandlers'] &&
      window['webkit']['messageHandlers'][name] &&
      window['webkit']['messageHandlers'][name]['postMessage']
    ) {
      window['webkit']['messageHandlers'][name]['postMessage'](paramsValue)
    }
  } else {
    // 安卓
    window['webview'] && window['webview'][name] && window['webview'][name](paramsValue)
  }
}

window.getWalletResul = this.getWalletAcs
postAppPrams('getUserInfo')
window.getUserInfoResult = this.loadUserInfo
```

## vue虚拟Dom原理流程

```
简单概括为三点：
1、用javascript对象模拟真实dom树，并渲染这个dom树
2、diff算法 - 比较两颗虚拟dom树的差异
3、pach算法 - 将两个虚拟dom对象的差异应用到真正的dom树上

只要状态发生改变，一定会执行render方法
render函数会插入jsx生成的dom结构，react会生成一个虚拟dom树，在每一次组价更新时，
在此react会通过其diff算法比较更新前后的新旧dom树，
比较以后，会找到最小差异的dom节点，并重新渲染
```

## vue的Dom跟新机制

## 虚拟dom详解（是什么，做了什么）

## setTimeOut，async  await, promise的执行顺序

## setTimeout  和 setInterval的区别

```
setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式，setTimeout() 只执行一次
setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数
```

## 为什么网页第二次打开更快

## webpack打包优化

https://www.jianshu.com/p/6b526cc31ba7

```
1：优化图片
使用 url-loader 优化， 将小图片转化成base64压缩,防止小图片太多请求次数太多。
2：分离第三方包
打包后的bundle.js文件夹较大，所以每次加载的时候，请求比较慢，所以有必要在打包时将第三方包分离出来。使用CommonsChunkPlugin 插件进行配置。
3：分离 css 文件并压缩 css 文件
使用 extract-text-webpack-plugin 插件将css文件分离出来。为了使项目加载时候尽早优先加载css样式，也为了解决js文件体积过大的问题
4: 压缩 js 文件
使用 uglifyjs-webpack-plugin 将js压缩，减少打包后的 vendor.js , bundle.js 等js的文件大小
5：压缩Html
为了减少打包后的文件体积，使性能更好，效率更高，提高加载速度，打包时有必要进行压缩。
使用html-webpack-plugin 进行压缩
```

## webpack打包核心

https://www.jianshu.com/p/b8d6ac3041e3

### 什么是 webpack

```
webpack 是一个模块打包机，将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源

当 webpack 处理程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle
```

- 主要承担如下功能：
  - 打包：将多个文件 打包成 一个文件，减少服务器压力和下载带宽
  - 转换：将预编译语言 转换成 浏览器识别的语言
  - 优化：性能优化

webpack 特点：

- **代码拆分**

  > webpack 有两种组织模块的依赖方式，同步、异步

  > 异步依赖将作为分割点，形成一个新的块；在优化了依赖树之后，每一个异步区块都将作为一个文件被打包

- **智能解析**

  > webpack 有一个智能解析器，几乎可以处理任何第三方库

  > 无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件；甚至在加载依赖的时候，允许使用动态表达式 require("./templates/" + name + ".jade")

- **快速运行**

  > webpack 使用异步 I/O 、多级缓存提高运行效率，使得 webpack 以难以令人置信的速度 **快速增量编译

### 核心概念：入口 entry

- **作用**

  > 告诉 webpack 从哪个文件开始构建，这个文件将作为 webpack 依赖关系图的起点
  >
  > **配置 单入口**
  >
  > ```java
  > // webpack 配置
  > module.exports = {
  >   entry: {
  >     main: './src/main.js'
  >   }
  > };
  > ```

### 核心概念：出口 output

- **作用**

  > 告诉 webpack 在哪里输出 构建后的包、包的名称 等
  >
  > **配置 单出口**
  >
  > ```java
  > // webpack 配置
  > const path = require('path');
  > 
  > module.exports = {
  >   entry: main: './src/main.js',
  >   output: {
  >     filename: 'main.js',
  >     path: path.resolve(__dirname, 'dist')
  >   }
  > };
  > ```

### 核心概念：loader

**作用**

> loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）
>
> Loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..）

> loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块
>
> ```tsx
> // webpack 配置
> module.exports = {
>   module: {
>     rules: [{ 
>         test: /\.css$/, 
>         use: ['style-loader', 'css-loader', 'postcss-loader']
>     }]
>   }
> };
> ```

### 核心概念：plugin

- **作用**

  > 可以处理各种任务，从打包优化和压缩，一直到重新定义环境中的变量
  >
  > 通过插件我们可以扩展 webpack，加入自定义的构建行为，使 webpack 可以执行更广泛的任务，拥有更强的构建能力。
  >
  > ```java
  > // webpack 配置
  > const HtmlWebpackPlugin = require('html-webpack-plugin'); 
  > 
  > module.exports = {
  > plugins: [
  >  new HtmlWebpackPlugin({
  >      template: './src/index.html'
  >  })
  > ]
  > };
  > ```

### 核心概念：模式 mode

- **作用**

  > 告诉 webpack 使用相应模式的内置优化
  >
  > **使用**
  >
  > ```java
  > // webpack 配置
  > module.exports = {
  >   mode: 'production'
  > };
  > 
  > // 在 webpack 中区分两种 模式
  > if(process.env.NODE_ENV === 'development'){
  >     //开发环境 do something
  > }else{
  >     //生产环境 do something
  > }
  > ```

## MVC和MVVM的区别

```
MVC:
模型（Model）：数据保存
视图（View）：用户界面。
控制器（Controller）：业务逻辑
各部分之间的通信方式如下:
1.View 传送指令到 Controller
2.Controller 完成业务逻辑后，要求 Model 改变状态
3.Model 将新的数据发送到 View，用户得到反馈
所有通信都是单向的

MVVM:
Model ---->  每个页面单独数据
View ---->  每个页面中的HTML结构
Model ---- View ---- VM(ViewModel)
数据驱动、VM提供数据的双向绑定
```

## node怎么进行模拟接口

## Vue2和Vue3的区别

```
vue2:
使用Object.defineProperty数据劫持
Object.defineProperty 不能通过数组的下标操作，视图不会更新
视图添加订阅者，数据变化马上发布消息通知模板更新
当监听到值发生变化的时候立刻发布给模板，模板才能跟着改
为什么能够接收到发布者的消息，因为事先对你发起订阅的操作
我们只需遍历所有data对象中的所有属性，并对每一个属性使用Object.defineProperty劫持即可，当属性的值发生变化的时候，我们执行一系列的渲染视图的操作。

vue3:
使用Proxy代理
能对引用数据的增删改查全面监测
```

## vue单页面和多页面的区别

```
单页面应用（spa）
概念：只有一个html页面，所有跳转方式都是通过组件切换完成的。
优点：页面之间跳转流畅、组件化开发、组件可复用、开发便捷、易维护。
缺点：首屏加载较慢，加载整个项目中使用的css、js，SEO优化不好
1.用户体验：页面片段间的切换快，用户体验好，包括在移动设备上
2.能否实现转场动画：容易实现（手机app动效）
3.页面间传递数据：因为在一个页面内，页面间传递数据很容易实现
4.特别适用的范围：对体验要求高的应用，特别是移动应用

多页面应用（mpa）
概念：整个项目有多个html，所有跳转方式都是页面之间相互跳转的。
优点：首屏加载较快，只加载本页所使用的的css、js，SEO优化较好。
缺点：页面跳转较慢。
1.用户体验：页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上
2.能否实现转场动画：无法实现
3.页面间传递数据：依赖URL、cookie或者localstorage，实现麻烦
4.特别适用的范围：需要对搜索引擎友好的网站
```

<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20210915014846527.png" alt="image-20210915014846527" style="zoom: 33%;" />

## 商城列表的优化处理

```
移动端长列表性能优化如何做？下拉加载一直会向页面中填充数据，dom太多页面太卡咋办？

滚动数据太多是因为列表的DOM节点树太多导致。可以从减少列表中的DOM节点数量下手，比如实现一个虚拟列表或者用第三方组件，或者使用CANVAS直接绘制列表效果。关于DOM虚拟列表实现可以给点思路给你，10000个列表元素只创建可见区域10条的DOM节点。然后使用CSS定位固定列表元素垂直位置。
```

## 商城列表回到顶部的处理

```
1.使用锚标记返回页面顶部
使用HTML锚标记最简单，点击后会在地址栏显示这个锚标记。需要标记id特麻烦，尤其是每个页面都要使用，顶部展示又不一样。
页面顶部放置：
<a name="top" id="top"></a>

放置位置在<body>标签之后随便找个地方放都可以，只要靠近顶部即可。

页面底部放置：
<a href="#top" target="_self">返回顶部</a>

2.使用Javascript Scroll函数返回顶部
scrooll函数用来控制滚动条的位置，有两种很简单的实现方式：
方式1：
<a href="javascript:scroll(0,0)" mce_href="javascript:scroll(0,0)">返回顶部</a>
scroll第一个参数是水平位置，第二个参数是垂直位置，比如要想定位在垂直50像素处，改成scroll(0,50)就可以了。
方式2：
本方式是渐进式返回顶部，要好看一些，代码如下：
function pageScroll() {  
	window.scrollBy(0,-10);  
	scrolldelay = setTimeout('pageScroll()',100);
}  
<a href="pageScroll();" mce_href="pageScroll();">返回顶部</a>
这样就会动态返回顶部，不过虽然返回到顶部但是代码仍在运行，还需要在pageScroll函数加一句给停止掉。
if(document.body.scrollTop==0) clearTimeout(scrolldelay);

3.以一定的速度滑动返回顶部
$(".totop").click(function () { 
	var speed = 200;//滑动的速度
	$('html,body').animate({ scrollTop: 0 }, speed);//去顶部
	$('html,body').animate({ scrollTop: $('#footer').offset().top }, speed);//去底部 
}); 
```

## vue跨组件通信

```
provide和inject
有一种比较特殊的情况，即孙子组件或更深层次的组件通信
1.father.vue
<template>
	<div>
		<son :msgProp="msg"></son>
	</div>
</template>
<script>
export default {
	name: 'Father',
	data(){
	 return :{
	      msg:'我是父组件向子组件传递的参数。'
     }
   }
}
</script>
2.son.vue --------------------------------------
<template>
	<div>
		<grandson :prop="msg"></grandson>
	</div>
</template>
 
<script>
export default {
	name: 'Son',
	data(){
	 return :{
	      msg:'我是子组件向孙子组件传递的参数。'
     }
    },
    props: ['msgProp'],
}
</script>
如果想要grandson.vue和father.vue进行通讯，可以选择son作为中间组件进行传递，也可以考虑用vuex，不过还是要考虑性能问题。那么这时候我们可以考虑使用provide 和inject
1.father.vue
<template>
	<div>
		<son></son>
	</div>
</template>
 
<script>
export default {
	name: 'Father',
	provide: {
		name: '我是父组件传递给孙子组件的参数'
	}
}
2.grandson.vue（父级 -> 子组件 -> 孙子组件层级）
<template>
	<div>
		{{name}}
	</div>
</template>
 
<script>
export default {
	name: 'Grandson',
	inject: [name]
}
</script>
```

## v-if和v-show能否一起使用

```
将v-if指令替换为v-show指令，在条件为真的情况下，v-if将其所在dom及其子dom都删除，而v-show是将该dom加上了“display：none”，使其隐藏了起来
同时为true才显示。
v-show只是css的隐藏。
v-if是dom元素的销毁。
```

## v-if、v-show谁先执行

## vue父子组件的执行顺序

```
加载渲染过程
->父beforeCreate -> 父created -> 父beforeMount 
->子beforeCreate -> 子created -> 子beforeMount -> 子mounted
-> 父mounted

子组件更新过程
->父beforeUpdate
-> 子beforeUpdate -> 子updated
-> 父updated

父组件更新过程
父beforeUpdate -> 父updated

销毁过程
-> 父beforeDestroy
-> 子beforeDestroy -> 子destroyed
-> 父destroyed
-------------------------------------------------------------------------------------
1、父 beforeCreate
2、父 created
3、父 beforeMount
4、子 beforeCreate
5、子 created
6、子 beforeMount
7、子 mounted
8、父 mounted
子组件若有 props 的话更新顺序是四步，若没有的话，两步不触发父亲的钩子。

1、父 beforeUpdate
2、子 beforeUpdate
3、子 updated
4、父 updated
父组件更新顺序是

1、父 beforeUpdate
2、子 deactivated
3、父 updated
销毁过程是

1、父 beforeDestroy
2、子 beforeDestroy
3、子 destroyed
4、父 destroyed
```

## 移动端rem的适配原理

```
rem的移动适配原理：
设计稿宽度：600px
移动设备：600px
设置html的 font-size= 移动设备 / 设计稿宽度 * 100  = 100px，那么 1rem = 100px
设置一个盒子的宽度: width=1rem（即100px），此时这个盒子屏占比为：1/6。
当相同的代码运行在屏幕为300px的设备上时，js动态设置html的 font-size= 移动设备 / 设计稿宽度  * 100  = 50px，渲染出来的盒子就是1rem = 50px,这个盒子屏占比同样为：1/6。以此达到移动适配的效果

可以看出适配的的关键就在于js设置html的font-size:  font-size= 移动设备 / 设计稿宽度  * 100。那么这个公式怎么来的呢？
首先    移动设备 / 设计稿宽度    是渲染效果相对于设计稿的缩放比
然后    移动设备 / 设计稿宽度 * 100   乘以100是为了把font-size(=rem)放大100倍，因为当font-size小于浏览器支持最小字体大小的时候，浏览器会把fon-size默认为最小字体大小。也可以乘以其他值如50，但是为了好计算，一般设置为10或100，这样，我们只需要把设计稿宽度如 width=50px，除以10或100，改为5rem或0.5rem就好了。

如何设置html的font-size大小:
例如：设计稿为720px；当设备大于720px时，渲染比例1:1，当小于720px时，按照相应的比例缩小
var cw = document.documentElement.clientWidth; 
if (cw > 720) { 
    cw = 720; 
} 
document.getElementsByTagName("html")[0].style.fontSize = 100 * ( cw / 720) + 'px'
```

## Key 的作用是什么？可以用数组的 index（下标）代替么

```
a) key 的作用主要是为了高效的更新虚拟 DOM。另外 vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们。否则 vue 只会替换其内部属性而不会触发过渡效果

b) key 不能用 index 代替，index 在同一个页面会有重复的情况，违背了高效渲染的初衷。
```

## Vue2.x 设计理念

```
1. Vue2.0 引入了虚拟 dom
通过建立虚拟 dom 树, document.createDocumentFragment()，方法创建虚拟 dom树。一旦被监测的数据改变，会通过 Object.defineProperty 定义的数据拦截，截取到数据的变化。

2. 截取到的数据变化，从而通过订阅——发布者模式，触发 Watcher（观察者）,从而改变虚拟 dom 的中的具体数据。

3. 最后，通过更新虚拟 dom 的元素值，从而改变最后渲染 dom 树的值，完成双向绑定。
```

## Vue1.x 的设计理念是什么

```
a) 早期 Vue 是采用数据绑定、依赖收集的方式去观察数据变化并保留对实际DOM元素的引用，当有数据变化时进行对应的操作。

b) 少量数据更新对比 Virtual DOM 性能更好，坏处是大量数据更新、初始渲染性能、对比 Virtual DOM 性能更差
```

## Vue 的双向绑定的原理

```
a) 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。

b) 具体实现流程：
    i. 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就
    通知订阅者
    ii. 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，
    从而更新视图
    iii. 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅
    
c) 把下面的流程图说清楚就差不多了：
```

<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20211006022315166.png" alt="image-20211006022315166" style="zoom:50%;" />

## vue两种路由模式及原理

```
hash模式：
vue-router默认的是hash模式.
hash模式,是指url尾巴后的#号以及后面的字符.hash也被称为锚点,本身是用来做页面定位的.
hash虽然出现在url中,但不会被包括在http请求中,对后端完全没有影响,因此改变hash值不会重新加载页面.

history模式
history模主要是通过history Api的pushState()和replaceState()两个方法来实现的.pushState()可以改变url地址且不会发送请求,replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改
以上两个方法可以修改历史状态,下面三个方法可以切换(定位)历史状态
history.go(-2);//后退两次
history.go(2);//前进两次
history.back(); //后退
hsitory.forward(); //前进

history和hash的差异
history和hash都是利用浏览器的两种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location对象hash值变化事件来实现
history的url没有’#'号，hash反之
history修改的url可以是同域的任意url，hash是同文档的url
相同的url，history会触发添加到浏览器历史记录栈中，hash不会触发。

history和hash的优点和缺点
history比hash的url美观（没有’#'号）
history修改的url可以是同域的任意url，hash则只能是同文档的url
history模式往往需要后端支持，如果后端nginx没有覆盖路由地址，就会返回404，hash因为是同文档的url，即使后端没有覆盖路由地址，也不会返回404
hash模式下，如果把url作为参数传后端，那么后端会直接从’#‘号截断，只处理’#'号前的url，因此会存在#后的参数内容丢失的问题，不过这个问题hash模式下也有解决的方法。
```

## null和undefined有什么区别

```
1、定义
（1）undefined：是所有没有赋值变量的默认值，自动赋值
	在你没有进行对某个变量进行赋值的时候，他会被赋为undefined
（2）null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址
	null是人为进行赋值的。比如某个函数或者数组等等复杂类型，你如果想要进行一个舍弃，可以把它赋值为null。此时游览器会进行一个	回收

2、何时使用null?
当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null

3、null与undefined的异同点是什么呢？
共同点：都是原始类型，保存在栈中变量本地
不同点：
   （1）undefined——表示变量声明过但并未赋过值。它是所有未赋值变量默认值。
	例如：var a;    //a自动被赋值为undefined

   （2）null——表示一个变量将来可能指向一个对象。一般用于主动释放指向对象的引用。
	例如：var emps = ['ss','nn']; emps = null;     //释放指向数组的引用

4、延伸——垃圾回收站
它是专门释放对象内存的一个程序。
   （1）在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期；
   （2）总有一个对象不再被任何变量引用时，才释放。
```

## 小程序,uni-app的生命周期

```
小程序,uni-app： 
1. onLoad：首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。
2. onShow：加载完成后、后台切到前台或重新进入页面时触发
3. onReady：页面首次渲染完成时触发
4. onHide：从前台切到后台或进入其他页面触发
5. onUnload：页面卸载时触发
6. onPullDownRefresh：监听用户下拉动作
7. onReachBottom：页面上拉触底事件的处理函数
8. onShareAppMessage：用户点击右上角转发
```

## 小程序组件之间的通信

#### 父、子组件之间的通信

```
父组件向子组件传递数据
1.首先我们先将子组件在父组件中注册，并且在父组件上使用
2.我们去到父组件中的.json文件中，在"usingComponents"中进行注册
3.父(外部)组件向子(内)组件传递数据是通过在子组件上自定义属性的方式实现的,自定义属性可以是基本数据类型(数字Number,字符串		   String,布尔(Boolean)等)与复杂数据类型(对象Object,数组Array)
4.父组件中传递了数据，子组件中就要接收参数子组件中的.js文件中有一个Component对象，在这个对象中有一个properties的对象

子组件向父组件传递自对应事件
举个例子：我们在子组件中的wxml中，使用bind：tap监听了一个onClick方法
　　　　　在.js文件中的Component对象中的methods中使用onClick方法
　　　　　在onClick方法使用triggerEvent发送自定义事件
　　　　　例：methods:{
　　　　　　　　onClick(){
　　　　　　　　　　console.log('监听到点击事件')
　　　　　　　　　　const index = 1
　　　　　　　　　　this.triggerEvent("handleClick",{index},{})
　　　　　　　　}
　　　　　　 }
　　　　　//trigerEvent("method-name"，{index}，{});
　　　　　　该方法有3个参数：第一个参数：方法名，第二个参数：要传递的数据
　　　　　　
　在父组件中使用
　	例：
　　　　　在父组件中的.wxml文件中：
　　　　　<b-detail-swiper bind:handleClick="handleClick" />
　　　　　在父组件中的.js文件中
　　　　　在Page对象中
　　　　　handleClick(event){
　　　　　　//获取event对象
　　　　　　const index = event.detail.index;
　　　　　　console.log(index)
　　　　　}
　　　　　这样我们获取到子组件向父组件传递的数据
```

#### 非父子组件之间的通信

```
wx小程序中的非父子组件通信其实特别简单，
在我们创建小程序的时候就会生成一个app.js、app.json等文件
我们的非父子组件之间的通信就需要用到app.js文件

例子：
app.js文件：
　　　　　　App（{
　　　　　　　　　　onLaunch：function(){
　　　　　　　　　　　　
　　　　　　　　　　},
　　　　　　　　　　addObj(obj){
　　　　　　　　　　　　this.globalData.proList.push(obj)
　　　　　　　　　　}
　　　　　　　　　　globalData:{
　　　　　　　　　　　name:'',
　　　　　　　　　　　proList:[]　
　　　　　　　　　　}
　　　　　　　　}）
注：home组件跟profile组件不是父子组件的关系
在home跟profile组件的js文件中我们先进行引用，这一步是必须的，先获取全局对象嘛
const app = getApp();

发送数据
home.js文件:
　　const app = getApp();
　　Page({
　　　　onLoad:function(options){
　　　　　　app.globalData.name = 'b-clouds'
　　　　}
　　})
在home.js文件中，我们将app中的globalData中的name属性的值改为'b-clouds'，
这时全局对象中的name属性的值就变成了'b-clouds'

获取数据
profile.js文件：
　　const app = getApp();
　　Page({
　　　　onLoad:function(options){
　　　　
　　　　},
　　　　//onClick只是一个单纯的点击事件
　　　　onClick(){
　　　　　　const name = app.globalData.name;
　　　　　　console.log(name)
　　　　　　//控制台打印出来的结果就是:   b-clouds
　　　　}
　　})

上面的只是String类型数据的传递，number跟String类型传递数据的方法是一样的

传递数据
而对象和数组传递数据的方式是一样的
　　例子：
home.js:
　　　Page：{
　　　　data:{
　　　　　　id:1001,
　　　　　　name:'b-clouds',
　　　　　　age:22,
　　　　　　height:1.81
　　　　}
　　　　onClick（）{
　　　　　　const obj = {}
　　　　　　obj.id = this.data.id
　　　　　　obj.name = this.data.name
　　　　　　obj.age = this.data.age
　　　　　　obj.height = this.data.height
　　　　　　app.addObj(obj)
　　　　}
　　　}
这样在home文件中就将全局对象中的proList的值改变；

获取数据
profile.js文件：
　　　const app = getApp();
　　　Page({
　　　　data:{
　　　　　proList:[]
　　　　}
　　　　//监听页面显示
　　　　onShow:function(){
　　　　　　const proList = app.globalData.proList
　　　　　　this.setData({
　　　　　　　　proList    //es6增强语法：   proList：proList    ===    proList
　　　　　　})
　　　　}
　　　})
　profile.wxml文件：
　　　这里就可以直接使用mastache语法使用proList    {{proList}}
```

## Ts 泛型

```
泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。
<T>  泛型变量T       T表示任何类型
let arr:Array<number> =[1,2,3];

定义多个类型
let arr:Array<number|string> =['1',2,3];
```

## h5与原生交互

```
app调用h5
在h5中暴露一些全局对象或方法，然后在原生app中调用全局对象

h5调用app
因为H5不能直接访问app
由app向h5注入一个全局js对象，然后h5直接访问这个对象
```

## Vue 动态路由的实现

```
Vue项目实现动态路由的方式大体可分为两种：
1.前端将全部路由规定好，登录时根据用户角色权限来动态展示路由；
2.路由存储在数据库中，前端通过接口获取当前用户对应路由列表并进行渲染；

	1.1
	拦截路由->获取角色->保存角色到localStorage(用户登录进来只会从后台取一次，其余都从本地取,所以用户，只有退出在登录路由	 才	  会更新)->对路由进行过滤，判断，什么展示什么不展示->获取到路由列表中的数据，判断角色中是否包含对应的角色，进行push操作

    2.1利用全局前置守卫对路由信息进行判断

    1-判断用户是否登录1.1-若未登录，跳转至登录页面1.2-若已经登录，判断是否已获取路由列表1.2.1-若未获取，从后端获取、解析并保	存到Vuex中1.2.2-若已获取，跳转至目标页面

    这里我没做太多考察，直接将取到数据存储到了Vuex中，在实际项目应用的过程中应考虑数据存储的安全性。

    如何实现路由列表解析？

    将JSON格式的路由信息解析为JavaScript列表对象；
    利用列表对象的filter方法实现解析函数，通过component判断是否为布局组件；
    若为布局组件，使用布局组件代替component字符串；
    若为具体页面，使用loadView函数加载对应的具体页面；
    利用 router.addRoutes 方法动态添加路由
    这一步就很简单了，将解析好的路由列表通过router.addRoutes方法添加到Router实例中即可。
```

## slot插槽

插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。

插槽分为：匿名插槽| 具名插槽| 作用域插槽

#### 匿名插槽

它不用设置名称属性，可以放置在组件的任意位置；可以理解为父传入样式及内容，子负责展示

```
index.vue  父组件
<slot2 :data="" color="" >
      <!--匿名插槽-->
      <ul>
          <li>1</li>
          <li>2</li>
      </ul>
      <ul slot>
          <li>1</li>
          <li>2</li>
      </ul>
</slot2>

slot2.vue   子组件
<!--匿名插槽-->
<slot></slot>
```

#### 具名插槽

插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置

```
index.vue  父组件
<slot2>
    <div slot="n1">
    	<h2>具名插槽n1</h2>
    </div>
    <!--具名插槽 传入父的值-->
    <div slot="n2">
    	<h2>具名插槽n2</h2>
        <ul>
            <li v-for="(v,i) in arr"  :key="i">{{v}}</li>
        </ul>
    </div>
</slot2>

slot2.vue   子组件
<!--具名插槽-->
<slot name="n1"></slot>
<slot name="n2"></slot>
```

#### 作用域插槽

官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。

什么意思呢，就是前面两种，都是在组件的模板里面写

作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容， 而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）相当于父组件提供一套样式，数据都是子组件的。

```
index.vue  父组件
<slot2>
    <div slot-scope="scope">  
		{{scope.title}}   
	</div>
</slot2>

slot2.vue   子组件
<!-- 作用域插槽 -->
<slot :title="title"></slot>

子组件中传入数组
index.vue  父组件
<slot2>
    <div slot-scope="scope">
        <ul>
        	<li v-for="(v,i) in scope.arr" :key="i">{{v}}</li>
        </ul>
    </div>
</slot2>

slot2.vue   子组件
<!-- 作用域插槽 -->
<slot :arr="arr"></slot>
data(){
    return{
      arr:[6,7,8,9,0]
    }
}
```

## js冒泡排序

```
1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。
2、比较完第一轮的时候，最后一个元素是最大的元素。
3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。

function bSort(arr) {
  var len = arr.length;
  for (var i = 0; i < len-1; i++) {
    for (var j = 0; j < len - 1 - i; j++) {
         // 相邻元素两两对比，元素交换，大的元素交换到后面
        if (arr[j] > arr[j + 1]) {
            var temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
  }
  return arr;
}

//举个数组
myArr = [20,18,27,19,35];
//使用函数
bSort(myArr)
```

```
算法：假设有n个人排成一行，每人手里都有一个数字，第一个人跟后一个人说你手里的数学比我小（大）吗？回答说小，两个人就互换了位置，一队下来是n-1次比较，
　　　 最终使得最后一个人手里的数字是最小（大）的。即 每一小循环（轮）确定一个最小或最大的数！
代码： 假设，总比较数量有s个数，当轮要比较数n=(s-i)个，则得比较s-1轮（外层循环），每轮比较n-1次（内层循环）

	    var arr=[311,42,33,5,21,6,7,312];
        console.log(arr); 
        for (var i=0;i<arr.length-1;i++){ // 轮：s-1轮
            for (var j=0;j<arr.length-i-1;j++){ //比较次数： (s-i)-1比较次数
                if(arr[j]>arr[j+1]){//交换逻辑
                    var sub=arr[j+1];
                    arr[j+1]=arr[j];
                    arr[j]=sub;
                }
            }
        }
        console.log(arr);
```

## js事件代理

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

```
<ul id="ul">
	<li>1</li>
    <li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ul>
<script>
	let ul = document.querySelector('#ul')
	ul.addEventListener('click', (event) => {
		console.log(event.target);
	})
</script>
```

事件代理的方式相较于直接给目标注册事件来说，有以下优点：

- 节省内存
- 不需要给子节点注销事件

## keep-alive应用场景

```
列表页面 ——进入详情页 —— 后退到列表页（缓存列表页的原来数据以及滚动位置）
https://blog.csdn.net/u014678583/article/details/107387891/

keep-alive的常用应用场景：
1.form表单内容缓存（路由改变不刷新页面）
2.单页面状态内容缓存
3.列表list滚动条高度缓存（例如今日头条点击进入内容详情，返回依旧在那个位置）还有其他一些用处就不一一说明了。
```

## 移动端的兼容性

```

```

## mixin 和 mixins 区别

`mixin` 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。

```
Vue.mixin({
    beforeCreate() {
        // ...逻辑
        // 这种方式会影响到每个组件的 beforeCreate 钩子函数
    }
})
```

虽然文档不建议我们在应用中直接使用 `mixin`，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 `ajax` 或者一些工具函数等等。

`mixins` 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 `mixins` 混入代码，比如上拉下拉加载数据这种逻辑等等。

另外需要注意的是 `mixins` 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并

## 首屏加载优化

#### DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```
<link rel="dns-prefetch" href="//yuchengkai.cn">
```

#### 预加载

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。

预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```
<link rel="preload" href="http://example.com">
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

#### 预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```
<link rel="prerender" href="http://example.com"> 
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。

#### 懒执行

懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

#### 懒加载

懒加载就是将不关键的资源延后加载。

懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

#### CDN

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

#### 图片优化

##### 计算图片大小

对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 **RGBA** 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。

但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。

了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：

- **减少像素点**
- **减少每个像素点能够显示的颜色**

##### 图片加载优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG

#### 节流，防抖

## 前端项目如何按需编译

1、vue异步组件技术

vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。
但是，这种情况下一个组件生成一个js文件。

例如：

```
{
    path: '/promisedemo',
    name: 'PromiseDemo',
    component: resolve => require(['../components/PromiseDemo'], resolve)
}
```

2、es的import()

需要webpack > 2.4

需要安装syntax-dynamic-import 插件

（1）使用webpack中的syntax-dynamic-import 插件

​	npm install --save-dev babel-plugin-syntax-dynamic-import

（2）配置.babelrc文件（若没有，则新建这个文件，和package.json同级）

​	{

​		"plugins": ["syntax-dynamic-import"]

​	}

（3）Vue-route提供语法：

```
// 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。
const ImportFuncDemo1 = () => import('../components/ImportFuncDemo1')
const ImportFuncDemo2 = () => import('../components/ImportFuncDemo2')
// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。
// const ImportFuncDemo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo')
// const ImportFuncDemo2 = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo2')
```

3、webpack提供的require.ensure()

vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。
这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。

例如：

```
{
　　path: '/promisedemo',
　　name: 'PromiseDemo',
　　component: r => require.ensure([], () => r(require('../components/PromiseDemo')), 'demo')
},
{
　　path: '/hello',
　　name: 'Hello',
　　component: r => require.ensure([], () => r(require('../components/Hello')), 'demo')
}
```